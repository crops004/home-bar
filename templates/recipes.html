{% extends "base.html" %}
{% block title %}Recipe Collection{% endblock %}
{% block content %}
    <div class="px-4 sm:px-6 pt-0 pb-28 sm:pb-10">
    <div class="sticky top-0 sm:top-[var(--desktop-nav-offset)] z-30 bg-background-dark/95 supports-[backdrop-filter]:bg-background-dark/80 backdrop-blur pt-4 sm:pt-0 pb-4 space-y-6">
        <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
            <h1 class="text-3xl font-semibold text-text-normal">Recipe Collection</h1>
            <button
                type="button"
                onclick="openAddModal()"
                class="inline-flex h-11 w-48 items-center justify-center gap-2 rounded-full bg-logo px-5 py-2 text-sm font-medium text-light-text-normal hover:ring-2 hover:ring-logo transition"
            >
                <span class="text-xl leading-none">+</span>
                Add New Recipe
            </button>
        </div>

        <div class="rounded-2xl border border-border bg-background-mid p-4 sm:p-5">
            <div class="flex items-start justify-between gap-3">
                <div>
                    <h2 class="text-lg font-semibold text-text-normal">Filters</h2>
                    <p class="text-sm text-text-muted">Use + to expand filter controls.</p>
                </div>
                <button
                    id="recipe-filters-toggle"
                    type="button"
                    class="inline-flex h-9 w-9 items-center justify-center rounded-full border border-border text-text-normal hover:bg-background-light transition"
                    aria-expanded="false"
                    aria-controls="recipe-filters-panel"
                    title="Toggle filters"
                >
                    <svg id="recipe-filters-plus" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="size-5">
                        <path d="M10 4.75a.75.75 0 0 1 .75.75v3.75h3.75a.75.75 0 0 1 0 1.5h-3.75v3.75a.75.75 0 0 1-1.5 0v-3.75H5.5a.75.75 0 0 1 0-1.5h3.75V5.5a.75.75 0 0 1 .75-.75Z" />
                    </svg>
                    <svg id="recipe-filters-minus" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="size-5 hidden">
                        <path d="M5.75 10a.75.75 0 0 1 .75-.75h7a.75.75 0 0 1 0 1.5h-7a.75.75 0 0 1-.75-.75Z" />
                    </svg>
                    <span class="sr-only">Toggle recipe filters</span>
                </button>
            </div>
            <div id="recipe-filters-panel" class="hidden mt-4">
                <div class="flex flex-wrap items-center gap-3 rounded-2xl border border-border bg-background-mid/40 p-4">
                    <div class="flex flex-wrap items-center gap-2">
                        <span class="text-xs uppercase tracking-wide text-text-muted">View</span>
                        <button type="button" class="view-toggle inline-flex items-center gap-2 rounded-full border border-border px-3 py-1 text-xs text-text-muted hover:bg-background-light transition" data-view="can">Can Make</button>
                        <button type="button" class="view-toggle inline-flex items-center gap-2 rounded-full border border-border px-3 py-1 text-xs text-text-muted hover:bg-background-light transition" data-view="all">All Recipes</button>
                    </div>
                    <div class="flex flex-wrap items-center gap-2">
                        <span class="text-xs uppercase tracking-wide text-text-muted">Base Spirit</span>
                        <button type="button" class="spirit-filter inline-flex items-center gap-2 rounded-full border border-border px-3 py-1 text-xs text-text-muted hover:bg-background-light transition" data-spirit="all">All</button>
                        <button type="button" class="spirit-filter inline-flex items-center gap-2 rounded-full border border-border px-3 py-1 text-xs text-text-muted hover:bg-background-light transition" data-spirit="gin">Gin</button>
                        <button type="button" class="spirit-filter inline-flex items-center gap-2 rounded-full border border-border px-3 py-1 text-xs text-text-muted hover:bg-background-light transition" data-spirit="whiskey">Whiskey</button>
                        <button type="button" class="spirit-filter inline-flex items-center gap-2 rounded-full border border-border px-3 py-1 text-xs text-text-muted hover:bg-background-light transition" data-spirit="rum">Rum</button>
                        <button type="button" class="spirit-filter inline-flex items-center gap-2 rounded-full border border-border px-3 py-1 text-xs text-text-muted hover:bg-background-light transition" data-spirit="tequila">Tequila</button>
                    </div>
                    <div class="w-full sm:w-auto sm:ml-auto">
                        <div class="relative w-full sm:w-60">
                            <input
                                type="text"
                                id="recipe-search"
                                placeholder="Filter..."
                                class="modal-input w-full pr-20"
                            />
                            <button
                                type="button"
                                id="recipe-search-clear"
                                class="absolute right-2 top-1/2 -translate-y-1/2 text-xs font-semibold text-text-normal px-3 py-1 rounded-full border border-logo bg-background-light hover:bg-background-mid transition opacity-0 invisible pointer-events-none"
                                aria-label="Clear search"
                                aria-hidden="true"
                            >
                                Clear
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Recipe Cards -->
    {% if all_recipes %}
    <div id="recipes-container" class="mt-6 space-y-4">
        {% for group in all_recipes | groupby('base_spirit_category') %}
        {% set spirit = ((group.grouper or '') | trim) | default('Unknown', true) %}
        {% set spirit_key = spirit.lower() %}
        {% set group_recipes = group.list | sort(attribute='drink', case_sensitive=False) %}
        {% set panel_id = 'recipes-section-' ~ loop.index %}
        <section class="recipe-group ui-card relative overflow-visible" data-spirit="{{ spirit_key }}">
            <button type="button" class="recipe-group-toggle ui-card-header flex w-full items-center justify-between gap-3 px-4 py-3 text-left" data-target="{{ panel_id }}" aria-expanded="false">
                <div class="flex flex-col">
                    <span class="text-xs uppercase tracking-wide text-text-muted">Base Spirit</span>
                    <span class="text-lg font-semibold text-text-normal">{{ spirit }}</span>
                </div>
                <div class="flex items-center gap-3">
                    <span class="recipe-group-count rounded-full bg-background-dark px-3 py-1 text-xs text-text-muted">{{ group_recipes | length }} recipe{% if group_recipes | length != 1 %}s{% endif %}</span>
                    <svg class="size-4 text-text-muted transition-transform" data-chevron aria-hidden="true" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 0 1 1.414 0L10 10.586l3.293-3.293a1 1 0 1 1 1.414 1.414l-4 4a1 1 0 0 1-1.414 0l-4-4a1 1 0 0 1 0-1.414Z" clip-rule="evenodd" />
                    </svg>
                </div>
            </button>
            <div id="{{ panel_id }}" class="recipe-group-panel hidden border-t border-border bg-background-dark rounded-b-2xl overflow-hidden">
                <div class="recipe-group-grid grid items-start p-4 sm:grid-cols-2 xl:grid-cols-3">
                {% for recipe in group_recipes %}
                {% set summary_spirit = (recipe.spirit_summary | default('', true)) | trim %}
                {% set summary_ingredients = (recipe.ingredient_summary | default('', true)) | trim %}
                <article
                    class="recipe-card ui-card ui-card-interactive relative flex flex-col"
                    data-drink="{{ recipe.drink|escape }}"
                    data-base-spirit="{{ recipe.base_spirit|default('', true)|escape }}"
                    data-base-category="{{ recipe.base_spirit_category|default(spirit, true)|escape }}"
                    data-spirit-summary="{{ recipe.spirit_summary|default('', true)|escape }}"
                    data-ingredients="{{ summary_ingredients|escape }}"
                    data-available="{{ 'true' if recipe.available else 'false' }}"
                >
                    <button
                        type="button"
                        aria-expanded="false"
                        class="recipe-card-toggle w-full text-left p-4 flex flex-col gap-3 cursor-pointer focus:outline-none focus-visible:ring-2 focus-visible:ring-logo"
                    >
                        <header class="flex justify-between items-start gap-3">
                            <h3 class="text-lg font-semibold text-text-normal truncate">{{ recipe.drink }}</h3>
                        </header>
                        <p class="recipe-summary text-xs uppercase tracking-wide text-text-muted whitespace-nowrap overflow-hidden text-ellipsis" title="{{ summary_spirit or 'No spirits listed' }}">
                            {{ summary_spirit or 'No spirits listed' }}
                        </p>
                    </button>
                    <div class="recipe-card-details hidden flex-1 border-t border-border bg-background-dark p-4 text-sm text-text-normal">
                        <p class="text-text-muted">Select to load details.</p>
                    </div>
                </article>
                {% endfor %}
                </div>
            </div>
        </section>
        {% endfor %}
    </div>
    <p id="recipes-empty" class="mt-6 hidden text-sm text-text-muted">No recipes match your filters.</p>
    {% else %}
    <p class="mt-6 text-text-muted">No recipes yet. Use the button above to add your first cocktail.</p>
    {% endif %}

    <!-- Add Recipe Modal -->
    <div id="add-modal" class="fixed inset-0 z-[999] hidden flex items-start sm:items-center justify-center bg-black/70 backdrop-blur-sm p-3 sm:p-4 overflow-y-auto">
        <div class="modal-panel max-h-[calc(100dvh-1.5rem)] sm:max-h-[calc(100dvh-2rem)] flex flex-col">
            <div class="modal-header">
                <h2 class="text-xl font-semibold text-text-normal">Add New Recipe</h2>
                <button type="button" onclick="closeAddModal()" class="text-text-muted hover:text-text-normal text-2xl leading-none">&times;</button>
            </div>
            <form id="add-recipe-form" method="post" class="flex flex-1 min-h-0 flex-col">
                <div class="modal-body flex-1 min-h-0 space-y-3">
                    <div class="grid gap-4 sm:grid-cols-2">
                        <label class="flex items-center gap-3 text-sm sm:col-span-2">
                            <span class="modal-label w-24 shrink-0 whitespace-nowrap">Drink Name</span>
                            <input type="text" id="add-drink" name="drink" required class="modal-input min-w-0 flex-1" />
                        </label>
                        <label class="flex items-center gap-3 text-sm">
                            <span class="modal-label w-24 shrink-0">Base Spirit</span>
                            <div class="base-spirit-field relative min-w-0 flex-1">
                                <input type="text" id="add-base_spirit-input" placeholder="Type to filter base spirits..." oninput="filterBaseSpirit('add')" class="modal-input w-full" autocomplete="off" />
                                <div id="add-base_spirit-dropdown" class="ingredient-dropdown hidden" role="listbox"></div>
                            </div>
                            <select id="add-base_spirit" name="base_spirit" class="hidden">
                                <option value="">None</option>
                                {% for cat in lists['categories'] %}
                                    <option value="{{ cat }}">{{ cat }}</option>
                                {% endfor %}
                                {% for cat, subs in lists['subcategories'].items() %}
                                    {% for sub in subs %}
                                        <option value="{{ sub }}">{{ sub }} ({{ cat }})</option>
                                    {% endfor %}
                                {% endfor %}
                            </select>
                        </label>
                        <label class="flex items-center gap-3 text-sm">
                            <span class="modal-label w-24 shrink-0">Glass</span>
                            <select id="add-glass" name="glass" class="modal-input min-w-0 flex-1">
                                <option value="">None</option>
                                {% for glass in lists['glass_types'] %}
                                    <option value="{{ glass }}">{{ glass }}</option>
                                {% endfor %}
                            </select>
                        </label>
                        <label class="flex items-center gap-3 text-sm">
                            <span class="modal-label w-24 shrink-0">Garnish</span>
                            <input type="text" id="add-garnish" name="garnish" class="modal-input min-w-0 flex-1" />
                        </label>
                        <label class="flex items-center gap-3 text-sm">
                            <span class="modal-label w-24 shrink-0">Method</span>
                            <select id="add-method" name="method" class="modal-input min-w-0 flex-1">
                                <option value="">None</option>
                                {% for method in lists['methods'] %}
                                    <option value="{{ method }}">{{ method }}</option>
                                {% endfor %}
                            </select>
                        </label>
                        <label class="flex items-center gap-3 text-sm">
                            <span class="modal-label w-24 shrink-0">Ice</span>
                            <select id="add_ice" name="ice" class="modal-input min-w-0 flex-1">
                                <option value="">None</option>
                                {% for ice in lists['ice_options'] %}
                                    <option value="{{ ice }}">{{ ice }}</option>
                                {% endfor %}
                            </select>
                        </label>
                    </div>
                    <label class="flex items-start gap-3 text-sm">
                        <span class="modal-label w-24 shrink-0 pt-2">Notes</span>
                        <textarea id="add-notes" name="notes" rows="3" class="modal-input min-w-0 flex-1"></textarea>
                    </label>

                    <div class="space-y-2">
                        <div class="flex items-center justify-between">
                            <h3 class="text-sm font-semibold uppercase tracking-wide text-text-muted">Ingredients</h3>
                            <button type="button" onclick="addIngredient('add')" class="modal-button-secondary text-xs">Add Ingredient</button>
                        </div>
                        <div id="add-ingredients-list" class="space-y-2">
                            <div class="ingredient-row flex flex-wrap items-center gap-2 rounded-lg border border-border bg-background-light/80 px-3 py-2">
                                <div class="ingredient-field relative flex-1 min-w-[12rem]">
                                    <input type="text" name="ingredient_0" class="ingredient-input modal-input w-full" placeholder="Type to search ingredients..." oninput="filterIngredients(this, 0)" autocomplete="off" />
                                    <div class="ingredient-dropdown hidden" role="listbox"></div>
                                </div>
                                <input type="text" name="quantity_0" placeholder="Qty" class="quantity-input modal-input w-20" />
                                <select name="unit_0" class="unit-select modal-input">
                                    {% for unit in lists['units'] %}
                                        <option value="{{ unit }}" {% if unit == 'oz' %}selected{% endif %}>{{ unit }}</option>
                                    {% endfor %}
                                </select>
                                <button type="button" onclick="removeIngredient(this)" class="ingredient-remove-btn rounded-full bg-red-600 px-3 py-1 text-xs text-white hover:bg-red-500 transition">Remove</button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" onclick="closeAddModal()" class="modal-button-secondary">Cancel</button>
                    <button type="submit" class="modal-button-primary">Save Recipe</button>
                </div>
            </form>
        </div>
    </div>    <!-- Edit Recipe Modal -->
    <div id="edit-modal" class="fixed inset-0 z-[999] hidden flex items-start sm:items-center justify-center bg-black/70 backdrop-blur-sm p-3 sm:p-4 overflow-y-auto">
        <div class="modal-panel max-h-[calc(100dvh-1.5rem)] sm:max-h-[calc(100dvh-2rem)] flex flex-col">
            <div class="modal-header">
                <h2 class="text-xl font-semibold text-text-normal">Edit Recipe</h2>
                <button type="button" onclick="closeEditModal()" class="text-text-muted hover:text-text-normal text-2xl leading-none">&times;</button>
            </div>
            <form id="edit-recipe-form" class="flex flex-1 min-h-0 flex-col">
                <div class="modal-body flex-1 min-h-0 space-y-3">
                    <input type="hidden" id="edit-original-drink" name="original_drink">
                    <div class="grid gap-4 sm:grid-cols-2">
                        <label class="flex items-center gap-3 text-sm sm:col-span-2">
                            <span class="modal-label w-24 shrink-0 whitespace-nowrap">Drink Name</span>
                            <input type="text" id="edit-drink" name="drink" required class="modal-input min-w-0 flex-1" />
                        </label>
                        <label class="flex items-center gap-3 text-sm">
                            <span class="modal-label w-24 shrink-0">Base Spirit</span>
                            <div class="base-spirit-field relative min-w-0 flex-1">
                                <input type="text" id="edit-base_spirit-input" placeholder="Type to filter base spirits..." oninput="filterBaseSpirit('edit')" class="modal-input w-full" autocomplete="off" />
                                <div id="edit-base_spirit-dropdown" class="ingredient-dropdown hidden" role="listbox"></div>
                            </div>
                            <select id="edit-base_spirit" name="base_spirit" class="hidden">
                                <option value="">None</option>
                                {% for cat in lists['categories'] %}
                                    <option value="{{ cat }}">{{ cat }}</option>
                                {% endfor %}
                                {% for cat, subs in lists['subcategories'].items() %}
                                    {% for sub in subs %}
                                        <option value="{{ sub }}">{{ sub }} ({{ cat }})</option>
                                    {% endfor %}
                                {% endfor %}
                            </select>
                        </label>
                        <label class="flex items-center gap-3 text-sm">
                            <span class="modal-label w-24 shrink-0">Glass</span>
                            <select id="edit-glass" name="glass" class="modal-input min-w-0 flex-1">
                                <option value="">None</option>
                                {% for glass in lists['glass_types'] %}
                                    <option value="{{ glass }}">{{ glass }}</option>
                                {% endfor %}
                            </select>
                        </label>
                        <label class="flex items-center gap-3 text-sm">
                            <span class="modal-label w-24 shrink-0">Garnish</span>
                            <input type="text" id="edit-garnish" name="garnish" class="modal-input min-w-0 flex-1" />
                        </label>
                        <label class="flex items-center gap-3 text-sm">
                            <span class="modal-label w-24 shrink-0">Method</span>
                            <select id="edit-method" name="method" class="modal-input min-w-0 flex-1">
                                <option value="">None</option>
                                {% for method in lists['methods'] %}
                                    <option value="{{ method }}">{{ method }}</option>
                                {% endfor %}
                            </select>
                        </label>
                        <label class="flex items-center gap-3 text-sm">
                            <span class="modal-label w-24 shrink-0">Ice</span>
                            <select id="edit_ice" name="ice" class="modal-input min-w-0 flex-1">
                                <option value="">None</option>
                                {% for ice in lists['ice_options'] %}
                                    <option value="{{ ice }}">{{ ice }}</option>
                                {% endfor %}
                            </select>
                        </label>
                    </div>
                    <label class="flex items-start gap-3 text-sm">
                        <span class="modal-label w-24 shrink-0 pt-2">Notes</span>
                        <textarea id="edit-notes" name="notes" rows="3" class="modal-input min-w-0 flex-1"></textarea>
                    </label>

                    <div class="space-y-2">
                        <div class="flex items-center justify-between">
                            <h3 class="text-sm font-semibold uppercase tracking-wide text-text-muted">Ingredients</h3>
                            <button type="button" onclick="addIngredient('edit')" class="modal-button-secondary text-xs">Add Ingredient</button>
                        </div>
                        <div id="edit-ingredients-list" class="space-y-2"></div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" onclick="closeEditModal()" class="modal-button-secondary">Cancel</button>
                    <button type="button" onclick="saveEdit()" class="modal-button-primary">Save Changes</button>
                </div>
            </form>
        </div>
    </div>    <div id="add-ingredient-modal" class="modal-backdrop hidden">
        <div class="modal-panel max-w-lg">
            <div class="modal-header">
                <h2 class="text-xl font-semibold text-text-normal">Add New Ingredient</h2>
                <button type="button" onclick="closeAddIngredientModal()" class="text-text-muted hover:text-text-normal text-2xl leading-none">&times;</button>
            </div>
            <form id="add-ingredient-form" class="flex flex-col max-h-[70vh]">
                <div class="modal-body space-y-4 text-sm">
                    <label class="flex items-center gap-3">
                        <span class="modal-label w-28 shrink-0">Ingredient Name</span>
                        <input type="text" id="new-ingredient-name" name="name" placeholder="Ingredient Name" required readonly class="modal-input min-w-0 flex-1" />
                    </label>
                    <label class="flex items-center gap-3">
                        <span class="modal-label w-28 shrink-0">Category</span>
                        <select name="category" id="new-ingredient-category" required class="modal-input min-w-0 flex-1">
                            <option value="" disabled selected>Select Category</option>
                            {% for category in lists['categories'] %}
                                <option value="{{ category }}">{{ category }}</option>
                            {% endfor %}
                        </select>
                    </label>
                    <label class="flex items-center gap-3">
                        <span class="modal-label w-28 shrink-0">Subcategory</span>
                        <select name="sub_category" id="new-ingredient-subcategory" class="modal-input min-w-0 flex-1">
                            <option value="">None</option>
                        </select>
                    </label>
                </div>
                <div class="modal-footer">
                    <button type="button" onclick="closeAddIngredientModal()" class="modal-button-secondary">Cancel</button>
                    <button type="submit" class="modal-button-primary">Add Ingredient</button>
                </div>
            </form>
        </div>
    </div>    <!-- Delete Confirmation Modal -->
    <div id="delete-modal" class="modal-backdrop hidden">
        <div class="modal-panel max-w-sm">
            <div class="modal-header">
                <h2 class="text-lg font-semibold text-text-normal">Delete Recipe</h2>
                <button type="button" onclick="closeDeleteModal()" class="text-text-muted hover:text-text-normal text-2xl leading-none">&times;</button>
            </div>
            <div class="modal-body space-y-4">
                <p id="delete-modal-message" class="text-sm text-text-normal"></p>
            </div>
            <div class="modal-footer">
                <button id="cancel-delete" type="button" class="modal-button-secondary">Cancel</button>
                <button id="confirm-delete" type="button" class="modal-button-danger">Delete</button>
            </div>
        </div>
    </div>

    <div id="recipes-data"
         class="hidden"
         data-categories='{{ lists["categories"] | tojson }}'
         data-subcategories='{{ lists["subcategories"] | tojson }}'
         data-spirit-categories='{{ spirit_categories | tojson }}'></div>

    <!-- Hidden select for units -->
    <script>
        let ingredientCount = 1;
        let editIngredientCount = 0;
        let currentDrink = null;
        let possibleIngredients = [];
        let allIngredientOptions = []; // Initialize as array
        let activeView = 'can';
        let activeSpiritFilter = 'all';

        const recipesDataElement = document.getElementById('recipes-data');
        const rawCategories = recipesDataElement?.dataset.categories || '[]';
        const rawSubcategories = recipesDataElement?.dataset.subcategories || '{}';
        const rawSpiritCategories = recipesDataElement?.dataset.spiritCategories || '[]';

        const baseSpiritCategoryLookup = (() => {
            const lookup = {};
            let subcategories = {};
            let categories = [];
            try {
                subcategories = JSON.parse(rawSubcategories);
            } catch (error) {
                console.error('Unable to parse subcategory data:', error);
            }
            Object.entries(subcategories).forEach(([category, subs]) => {
                const loweredCategory = (category || '').toLowerCase();
                if (loweredCategory) {
                    lookup[loweredCategory] = category;
                }
                (subs || []).forEach((sub) => {
                    const loweredSub = (sub || '').toLowerCase();
                    if (loweredSub) {
                        lookup[loweredSub] = category;
                    }
                });
            });

            try {
                categories = JSON.parse(rawCategories);
            } catch (error) {
                console.error('Unable to parse category data:', error);
            }
            (categories || []).forEach((category) => {
                const lowered = (category || '').toLowerCase();
                if (lowered && !lookup[lowered]) {
                    lookup[lowered] = category;
                }
            });
            return lookup;
        })();

        const spiritCategorySet = (() => {
            try {
                return new Set(JSON.parse(rawSpiritCategories).map((category) => String(category || '').toLowerCase()));
            } catch (error) {
                console.error('Unable to parse spirit categories:', error);
                return new Set();
            }
        })();

        function resolveBaseCategory(value) {
            const normalized = typeof value === 'string' ? value.trim() : '';
            if (!normalized) {
                return 'Unknown';
            }
            const match = baseSpiritCategoryLookup[normalized.toLowerCase()];
            if (match) {
                return match;
            }
            return normalized;
        }

        function summarizeSpiritIngredients(ingredients) {
            if (!Array.isArray(ingredients)) {
                return [];
            }
            const summary = [];
            const seen = new Set();
            ingredients.forEach((item) => {
                if (!item) {
                    return;
                }
                const name = (item.ingredient || '').trim();
                if (!name) {
                    return;
                }
                const candidates = [
                    item.sub_category || '',
                    item.category || '',
                ];
                let isSpirit = false;
                for (const candidate of candidates) {
                    if (!candidate) {
                        continue;
                    }
                    const resolved = resolveBaseCategory(candidate);
                    if (spiritCategorySet.has(resolved.toLowerCase())) {
                        isSpirit = true;
                        break;
                    }
                }
                if (!isSpirit) {
                    const resolvedFromName = resolveBaseCategory(name);
                    if (spiritCategorySet.has(resolvedFromName.toLowerCase())) {
                        isSpirit = true;
                    }
                }
                if (isSpirit && !seen.has(name)) {
                    summary.push(name);
                    seen.add(name);
                }
            });
            return summary;
        }

        function getRecipeGridMetrics(grid) {
            const gridStyle = window.getComputedStyle(grid);
            const rowHeight = parseFloat(gridStyle.gridAutoRows) || 8;
            let rowGap = parseFloat(gridStyle.rowGap);
            if (!Number.isFinite(rowGap)) {
                const gapTokens = String(gridStyle.gap || "").split(" ");
                rowGap = parseFloat(gapTokens[0]);
            }
            if (!Number.isFinite(rowGap)) {
                rowGap = 0;
            }
            return { rowHeight, rowGap, unit: rowHeight + rowGap };
        }

        function computeRecipeSpanFromHeight(height, metrics) {
            const unit = metrics.unit;
            if (unit <= 0) {
                return 1;
            }
            let span = Math.max(1, Math.ceil((height + metrics.rowGap) / unit));
            const allocatedHeight = (span * metrics.rowHeight) + ((span - 1) * metrics.rowGap);
            if (allocatedHeight < height) {
                span += 1;
            }
            return span;
        }

        function setRecipeCardSpan(card, span) {
            card.style.gridRowEnd = `span ${Math.max(1, span)}`;
        }

        function getCurrentCardSpan(card) {
            const raw = card.style.gridRowEnd || "";
            const match = raw.match(/span\s+(\d+)/i);
            if (!match) {
                return null;
            }
            const parsed = Number(match[1]);
            return Number.isFinite(parsed) && parsed > 0 ? parsed : null;
        }

        function getBaselineCollapsedSpan(grid, metrics) {
            const cards = Array.from(grid.querySelectorAll('.recipe-card'));
            for (const card of cards) {
                if (card === activeCard || card.classList.contains('hidden') || card.offsetParent === null) {
                    continue;
                }
                const h = Math.ceil(card.getBoundingClientRect().height) + 2;
                return computeRecipeSpanFromHeight(h, metrics);
            }
            return 1;
        }

        function updateRecipeCardSpan(card) {
            if (!card || card.classList.contains('hidden') || card.offsetParent === null) {
                return;
            }
            const grid = card.closest('.recipe-group-grid');
            if (!grid) {
                return;
            }
            const metrics = getRecipeGridMetrics(grid);

            if (card !== activeCard) {
                card.style.height = '';
                const collapsedSpan = Math.max(1, getBaselineCollapsedSpan(grid, metrics));
                setRecipeCardSpan(card, collapsedSpan);
                return;
            }

            const cardHeight = Math.ceil(card.getBoundingClientRect().height) + 2;
            const span = computeRecipeSpanFromHeight(cardHeight, metrics);
            setRecipeCardSpan(card, span);
        }

        function updateRecipeGroupLayout(group) {
            if (!group) {
                return;
            }
            const panel = group.querySelector('.recipe-group-panel');
            if (panel && panel.classList.contains('hidden')) {
                return;
            }
            const cards = group.querySelectorAll('.recipe-card');
            cards.forEach((card) => updateRecipeCardSpan(card));
        }

        function updateAllRecipeCardSpans() {
            document.querySelectorAll('.recipe-group').forEach((group) => {
                updateRecipeGroupLayout(group);
            });
        }

        function syncExpandedCardSpan(card) {
            if (!card || card !== activeCard || card.classList.contains('hidden')) {
                return;
            }

            const grid = card.closest('.recipe-group-grid');
            if (!grid) {
                return;
            }

            card.style.height = '';
            const metrics = getRecipeGridMetrics(grid);
            const naturalHeight = Math.ceil(card.getBoundingClientRect().height) + 2;
            const naturalSpan = computeRecipeSpanFromHeight(naturalHeight, metrics);
            setRecipeCardSpan(card, naturalSpan);
        }

        let recipeCardResizeObserver = null;
        function initRecipeCardResizeObserver() {
            if (!window.ResizeObserver) {
                return;
            }
            if (recipeCardResizeObserver) {
                recipeCardResizeObserver.disconnect();
            }
            recipeCardResizeObserver = new ResizeObserver((entries) => {
                entries.forEach((entry) => {
                    if (entry.target === activeCard) {
                        syncExpandedCardSpan(entry.target);
                    } else {
                        updateRecipeCardSpan(entry.target);
                    }
                });
                requestAnimationFrame(updateAllRecipeCardSpans);
            });
            document.querySelectorAll('.recipe-card').forEach((card) => {
                recipeCardResizeObserver.observe(card);
            });
        }

        function updateViewButtons() {
            document.querySelectorAll('.view-toggle').forEach((button) => {
                const isActive = button.dataset.view === activeView;
                button.classList.toggle('bg-background-light', isActive);
                button.classList.toggle('text-text-normal', isActive);
                button.classList.toggle('text-text-muted', !isActive);
            });
        }

        function updateSpiritButtons() {
            document.querySelectorAll('.spirit-filter').forEach((button) => {
                const isActive = button.dataset.spirit === activeSpiritFilter;
                button.classList.toggle('bg-background-light', isActive);
                button.classList.toggle('text-text-normal', isActive);
                button.classList.toggle('text-text-muted', !isActive);
            });
        }

        function setActiveView(view) {
            if (activeView === view) {
                return;
            }
            activeView = view;
            updateViewButtons();
            applyRecipeFilters();
        }

        function setActiveSpiritFilter(filter) {
            if (activeSpiritFilter === filter) {
                return;
            }
            activeSpiritFilter = filter;
            updateSpiritButtons();
            applyRecipeFilters();
        }

        function toggleRecipeSearchClear() {
            const searchInput = document.getElementById('recipe-search');
            const clearBtn = document.getElementById('recipe-search-clear');
            if (!searchInput || !clearBtn) {
                return;
            }
            const hasValue = searchInput.value.trim().length > 0;
            clearBtn.classList.toggle('invisible', !hasValue);
            clearBtn.classList.toggle('opacity-0', !hasValue);
            clearBtn.classList.toggle('pointer-events-none', !hasValue);
            clearBtn.setAttribute('aria-hidden', String(!hasValue));
        }

        function initTopFiltersToggle() {
            const toggle = document.getElementById('recipe-filters-toggle');
            const panel = document.getElementById('recipe-filters-panel');
            const plusIcon = document.getElementById('recipe-filters-plus');
            const minusIcon = document.getElementById('recipe-filters-minus');
            if (!toggle || !panel || !plusIcon || !minusIcon) {
                return;
            }

            const setState = (expanded) => {
                panel.classList.toggle('hidden', !expanded);
                plusIcon.classList.toggle('hidden', expanded);
                minusIcon.classList.toggle('hidden', !expanded);
                toggle.setAttribute('aria-expanded', String(expanded));
            };

            setState(false);

            toggle.addEventListener('click', () => {
                const expanded = toggle.getAttribute('aria-expanded') !== 'true';
                setState(expanded);
            });
        }

        function applyRecipeFilters() {
            const searchInput = document.getElementById('recipe-search');
            const searchValue = searchInput ? searchInput.value.trim().toLowerCase() : '';
            toggleRecipeSearchClear();
            const cards = document.querySelectorAll('.recipe-card');
            let visibleCount = 0;

            cards.forEach((card) => {
                const drinkName = (card.dataset.drink || '').toLowerCase();
                const baseSpirit = (card.dataset.baseSpirit || '').toLowerCase();
                const baseCategory = (card.dataset.baseCategory || '').toLowerCase();
                const spiritSummary = (card.dataset.spiritSummary || '').toLowerCase();
                const ingredients = (card.dataset.ingredients || '').toLowerCase();
                const isAvailable = card.dataset.available === 'true';

                const matchesView = activeView === 'all' || isAvailable;
                const matchesSpirit =
                    activeSpiritFilter === 'all' ||
                    baseSpirit.includes(activeSpiritFilter) ||
                    baseCategory.includes(activeSpiritFilter) ||
                    spiritSummary.includes(activeSpiritFilter);
                const matchesSearch =
                    !searchValue ||
                    [drinkName, baseSpirit, baseCategory, spiritSummary, ingredients].some((value) => value.includes(searchValue));

                const shouldShow = matchesView && matchesSpirit && matchesSearch;
                card.classList.toggle('hidden', !shouldShow);
                if (!shouldShow && activeCard === card) {
                    collapseCard(card);
                }
                if (shouldShow) {
                    visibleCount += 1;
                }
            });

            const emptyState = document.getElementById('recipes-empty');
            if (emptyState) {
                emptyState.classList.toggle('hidden', visibleCount !== 0);
            }

            document.querySelectorAll('.recipe-group').forEach((group) => {
                const visibleCards = Array.from(group.querySelectorAll('.recipe-card')).filter((card) => !card.classList.contains('hidden'));
                const countLabel = group.querySelector('.recipe-group-count');
                if (countLabel) {
                    const count = visibleCards.length;
                    countLabel.textContent = `${count} recipe${count === 1 ? '' : 's'}`;
                }
                group.classList.toggle('hidden', visibleCards.length === 0);
            });

            requestAnimationFrame(updateAllRecipeCardSpans);
        }

        function resetRecipeFilters() {
            activeView = 'can';
            activeSpiritFilter = 'all';
            const searchInput = document.getElementById('recipe-search');
            if (searchInput) {
                searchInput.value = '';
            }
            updateViewButtons();
            updateSpiritButtons();
            applyRecipeFilters();
        }

        function initRecipeAccordion() {
            document.querySelectorAll('.recipe-group-toggle').forEach((button) => {
                button.addEventListener('click', () => {
                    const targetId = button.dataset.target;
                    const panel = targetId ? document.getElementById(targetId) : null;
                    if (!panel) {
                        return;
                    }
                    const expanded = button.getAttribute('aria-expanded') === 'true';
                    button.setAttribute('aria-expanded', String(!expanded));
                    panel.classList.toggle('hidden', expanded);
                    const chevron = button.querySelector('[data-chevron]');
                    if (chevron) {
                        chevron.style.transform = expanded ? '' : 'rotate(180deg)';
                    }
                    requestAnimationFrame(() => {
                        const group = button.closest('.recipe-group');
                        updateRecipeGroupLayout(group);
                    });
                });
            });
        }

        const makeIngredientRowMarkup = (index) => `
            <div class="ingredient-row flex flex-wrap items-center gap-2 rounded-lg border border-border bg-background-light/80 px-3 py-2">
                <div class="ingredient-field relative flex-1 min-w-[12rem]">
                    <input
                        type="text"
                        name="ingredient_${index}"
                        class="ingredient-input modal-input w-full"
                        placeholder="Type to search ingredients..."
                        autocomplete="off"
                        oninput="filterIngredients(this, ${index})"
                    />
                    <div class="ingredient-dropdown hidden" role="listbox"></div>
                </div>
                <input type="text" name="quantity_${index}" placeholder="Qty" class="quantity-input modal-input w-20" />
                <select name="unit_${index}" class="unit-select modal-input">
                    {% for unit in lists['units'] %}
                        <option value="{{ unit }}" {% if unit == 'oz' %}selected{% endif %}>{{ unit }}</option>
                    {% endfor %}
                </select>
                <button type="button" onclick="removeIngredient(this)" class="ingredient-remove-btn rounded-full bg-red-600 px-3 py-1 text-xs text-white hover:bg-red-500 transition">Remove</button>
            </div>
        `;

        // Fetch the master list of ingredient names, categories, and subcategories on page load
        document.addEventListener('DOMContentLoaded', function() {
            fetch('/possible-ingredients-json')
                .then(response => {
                    if (!response.ok) {
                        return response.text().then(text => {
                        });
                    }
                    return response.json();
                })
                .then(data => {
                    possibleIngredients = data; // Array of all unique names, categories, and subcategories
                    // Use the data directly as allIngredientOptions, ensuring uniqueness with Set
                    allIngredientOptions = [...new Set(possibleIngredients)].sort(); // Remove duplicates and sort
                })
                .catch(error => {
                    console.error('Error fetching possible ingredients:', error);
                    allIngredientOptions = []; // Fallback to empty array if fetch fails
                });

            // Delete modal handlers
            document.getElementById('confirm-delete').addEventListener('click', function() {
                if (currentDrink) {
                    deleteRecipe(currentDrink);
                }
            });
            document.getElementById('cancel-delete').addEventListener('click', function() {
                closeDeleteModal();
            });

            initializeRecipeCards();
            initRecipeAccordion();
            initRecipeCardResizeObserver();
            initTopFiltersToggle();
            updateViewButtons();
            updateSpiritButtons();
            applyRecipeFilters();
            requestAnimationFrame(updateAllRecipeCardSpans);

            window.addEventListener('resize', () => {
                if (activeCard) {
                    syncExpandedCardSpan(activeCard);
                }
                requestAnimationFrame(updateAllRecipeCardSpans);
            });
            if (document.fonts && document.fonts.ready) {
                document.fonts.ready.then(() => {
                    if (activeCard) {
                        syncExpandedCardSpan(activeCard);
                    }
                    requestAnimationFrame(updateAllRecipeCardSpans);
                });
            }

            document.querySelectorAll('.view-toggle').forEach((button) => {
                button.addEventListener('click', () => {
                    const view = button.dataset.view || 'all';
                    setActiveView(view);
                });
            });

            document.querySelectorAll('.spirit-filter').forEach((button) => {
                button.addEventListener('click', () => {
                    const filter = button.dataset.spirit || 'all';
                    setActiveSpiritFilter(filter);
                });
            });

            const recipeSearchInput = document.getElementById('recipe-search');
            if (recipeSearchInput) {
                recipeSearchInput.addEventListener('input', applyRecipeFilters);
                recipeSearchInput.addEventListener('keydown', (event) => {
                    if (event.key === 'Escape') {
                        recipeSearchInput.value = '';
                        applyRecipeFilters();
                    }
                });
            }

            const recipeSearchClear = document.getElementById('recipe-search-clear');
            if (recipeSearchClear) {
                recipeSearchClear.addEventListener('click', () => {
                    if (recipeSearchInput) {
                        recipeSearchInput.value = '';
                    }
                    applyRecipeFilters();
                });
            }

            // Reselect the drink after edit
            const selectedDrink = sessionStorage.getItem('selectedDrink');
            if (selectedDrink) {
                const escapeValue = window.CSS && window.CSS.escape
                    ? window.CSS.escape(selectedDrink)
                    : selectedDrink.replace(/(["\\])/g, '\\$1');
                const card = document.querySelector(`.recipe-card[data-drink=\"${escapeValue}\"]`);
                if (card) {
                    toggleRecipeCard(card);
                }
                sessionStorage.removeItem('selectedDrink'); // Clear after use
            }

            // Handle Add Ingredient modal form submission
            const addIngredientForm = document.getElementById('add-ingredient-form');
            if (addIngredientForm) {
                addIngredientForm.addEventListener('submit', function(e) {
                    e.preventDefault();
                    const formData = new FormData(this);
                    fetch('/possible-ingredients', {
                        method: 'POST',
                        body: formData
                    })
                        .then(response => {
                            if (!response.ok) {
                            }
                            return response.text();
                        })
                        .then(() => {
                            // Update possibleIngredients and allIngredientOptions
                            const newName = formData.get('name').trim();
                            const newCategory = formData.get('category').trim();
                            const newSubCategory = formData.get('sub_category') || null;
                            possibleIngredients.push(newName);
                            if (newCategory) possibleIngredients.push(newCategory);
                            if (newSubCategory) possibleIngredients.push(newSubCategory);
                            allIngredientOptions = [...new Set(possibleIngredients)].sort();

                            // Update the input field
                            const targetInput = addIngredientForm.currentIngredientInput;
                            if (targetInput instanceof HTMLInputElement) {
                                targetInput.value = newName;
                                const dropdown = targetInput.closest('.ingredient-field')?.querySelector('.ingredient-dropdown');
                            if (dropdown) {
                                dropdown.classList.add('hidden');
                                dropdown.innerHTML = '';
                                dropdown.classList.remove('ingredient-dropdown--above');
                                dropdown.style.maxHeight = '';
                            }
                            }
                            addIngredientForm.currentIngredientInput = null;
                            closeAddIngredientModal();
                            // Clear the form
                            // Reset subcategory select
                            const subcatSelect = document.getElementById('new-ingredient-subcategory');
                            subcatSelect.innerHTML = '<option value="">None</option>';
                        })
                        .catch(error => {
                            console.error('Error adding ingredient:', error);
                            alert('Error adding ingredient. Check the console for details.');
                        });
                });

                // Dynamically populate subcategories based on selected category
                const categorySelect = document.getElementById('new-ingredient-category');
                const subcategorySelect = document.getElementById('new-ingredient-subcategory');
                categorySelect.addEventListener('change', function() {
                    const category = this.value;
                    subcategorySelect.innerHTML = '<option value="">None</option>'; // Reset to default
                    if (category) {
                        fetch(`/subcategories/${encodeURIComponent(category)}`)
                            .then(response => {
                                if (!response.ok) {
                                }
                                return response.json();
                            })
                            .then(subcategories => {
                                subcategories.forEach(sub => {
                                    const option = document.createElement('option');
                                    option.value = sub;
                                    option.textContent = sub;
                                    subcategorySelect.appendChild(option);
                                });
                            })
                            .catch(error => {
                                console.error('Error fetching subcategories:', error);
                            });
                    }
                });
            }
        });

        let activeCard = null;

        const FRACTION_DENOMS = [2, 3, 4, 6, 8];
        function formatQuantity(value) {
            if (value === null || value === undefined) {
                return '';
            }
            const raw = String(value).trim();
            if (!raw) {
                return '';
            }
            if (raw.includes('/')) {
                return raw;
            }
            const num = Number(raw);
            if (!Number.isFinite(num)) {
                return raw;
            }
            const sign = num < 0 ? '-' : '';
            const absVal = Math.abs(num);
            const whole = Math.floor(absVal);
            const frac = absVal - whole;

            let best = { n: 0, d: 1, diff: 1 };
            FRACTION_DENOMS.forEach((d) => {
                const n = Math.round(frac * d);
                const diff = Math.abs(frac - n / d);
                if (diff < best.diff) {
                    best = { n, d, diff };
                }
            });

            let numerator = best.n;
            let denominator = best.d;
            if (numerator === denominator && numerator !== 0) {
                // Roll over to the whole part if fraction rounds to 1
                numerator = 0;
            }
            const gcd = (a, b) => (b === 0 ? a : gcd(b, a % b));
            if (numerator && denominator) {
                const divisor = gcd(numerator, denominator);
                numerator /= divisor;
                denominator /= divisor;
            }

            const parts = [];
            const wholePart = whole + (best.n === best.d && best.n !== 0 ? 1 : 0);
            if (wholePart) {
                parts.push(String(wholePart));
            }
            if (numerator) {
                parts.push(`${numerator}/${denominator}`);
            }
            const result = parts.join(' ').trim();
            return result ? sign + result : '0';
        }

        function collapseCard(card) {
            if (!card) {
                return;
            }
            const details = card.querySelector('.recipe-card-details');
            if (details) {
                details.classList.add('hidden');
            }
            const toggle = card.querySelector('.recipe-card-toggle');
            if (toggle) {
                toggle.setAttribute('aria-expanded', 'false');
            }
            card.classList.remove('ring-2', 'ring-logo');
            card.classList.remove('is-active');
            if (activeCard === card) {
                activeCard = null;
            }
            if (currentDrink === card.dataset.drink) {
                currentDrink = null;
            }
            card.style.height = '';
            requestAnimationFrame(() => {
                updateRecipeCardSpan(card);
                updateAllRecipeCardSpans();
            });
        }

        function renderRecipeDetails(card, data) {
            const details = card.querySelector('.recipe-card-details');
            if (!details) {
                return;
            }

            const summaryLine = card.querySelector('.recipe-summary');
            if (summaryLine) {
                const spiritIngredients = summarizeSpiritIngredients(data.ingredients || []);
                const spiritSummary = spiritIngredients.join('  ');
                const ingredientNames = (data.ingredients || [])
                    .map((ing) => ing.ingredient)
                    .filter(Boolean);
                const ingredientSummary = ingredientNames.join('  ');
                const summaryText = spiritSummary || ingredientSummary || 'No spirits listed';
                summaryLine.textContent = summaryText;
                summaryLine.title = summaryText;
                card.dataset.spiritSummary = spiritSummary;
                card.dataset.ingredients = ingredientSummary;
            }

            const ingredientsMarkup = (data.ingredients || []).map(ing => {
                const quantity = formatQuantity(ing.quantity);
                const amount = [quantity, ing.unit].filter(Boolean).join(' ').trim() || '';
                const ingredientName = ing.ingredient || 'Ingredient';
                return `
                    <li class="flex items-center justify-between gap-3 text-sm text-text-normal">
                        <span class="flex-1 pr-4">${ingredientName}</span>
                        <span class="w-20 text-right whitespace-nowrap">${amount}</span>
                    </li>
                `;
            }).join('');

            const ingredientsHtml = ingredientsMarkup || '<li class="text-sm text-text-muted">No ingredients listed.</li>';

            const drinkName = data.name || card.dataset.drink;
            const glass = data.glass || 'None';
            const garnish = data.garnish || 'None';
            const method = data.method || 'None';
            const ice = data.ice || data.ice || 'None';
            const notes = data.notes || 'None';

            details.innerHTML = `
                <div class="recipe-details-stack" data-details-stack>
                    <section class="recipe-details-block">
                        <p class="text-xs uppercase tracking-wide text-text-muted mb-1">Ingredients</p>
                        <ul class="space-y-1">${ingredientsHtml}</ul>
                    </section>
                    <section class="recipe-details-block">
                        <div class="grid grid-cols-2 gap-2 text-xs uppercase tracking-wide text-text-muted">
                        <span>Glass</span><span class="text-sm text-text-normal">${glass}</span>
                        <span>Garnish</span><span class="text-sm text-text-normal">${garnish}</span>
                        <span>Method</span><span class="text-sm text-text-normal">${method}</span>
                        <span>Ice</span><span class="text-sm text-text-normal">${ice}</span>
                        </div>
                    </section>
                    <section class="recipe-details-block">
                        <p class="text-xs uppercase tracking-wide text-text-muted mb-1">Notes</p>
                        <p class="text-sm text-text-normal whitespace-pre-wrap">${notes}</p>
                    </section>
                    <section class="recipe-details-block">
                        <div class="flex flex-wrap gap-3">
                        <button type="button" class="recipe-card-edit rounded-full bg-logo px-4 py-2 text-light-text-normal text-sm hover:ring-2 hover:ring-logo transition">Edit</button>
                        <button type="button" class="recipe-card-delete rounded-full border border-border px-4 py-2 text-sm text-text-normal hover:bg-background-light transition">Delete</button>
                        </div>
                    </section>
                </div>
            `;

            const editButton = details.querySelector('.recipe-card-edit');
            const deleteButton = details.querySelector('.recipe-card-delete');

            if (editButton) {
                editButton.addEventListener('click', () => {
                    openEditModal(drinkName);
                });
            }
            if (deleteButton) {
                deleteButton.addEventListener('click', () => {
                    currentDrink = drinkName;
                    const modal = document.getElementById('delete-modal');
                    const message = document.getElementById('delete-modal-message');
                    message.textContent = `Are you sure you want to delete ${drinkName}?`;
                    if (modal) {
                        modal.classList.remove('hidden');
                        modal.style.display = 'flex';
                    }
                });
            }

            requestAnimationFrame(() => {
                syncExpandedCardSpan(card);
                updateRecipeCardSpan(card);
                updateAllRecipeCardSpans();
            });
        }

        function loadRecipeDetails(card) {
            const drink = card.dataset.drink;
            const details = card.querySelector('.recipe-card-details');
            if (!details) {
                return;
            }

            details.innerHTML = '<p class="text-sm text-text-muted">Loading details...</p>';

            fetch(`/recipe/${encodeURIComponent(drink)}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    const baseSpiritValue = data.base_spirit && data.base_spirit.trim()
                        ? data.base_spirit.trim()
                        : '';
                    card.dataset.baseSpirit = baseSpiritValue;
                    const resolvedCategory = resolveBaseCategory(baseSpiritValue);
                    card.dataset.baseCategory = resolvedCategory;
                    renderRecipeDetails(card, data);
                    card.dataset.loaded = 'true';
                    requestAnimationFrame(() => {
                        syncExpandedCardSpan(card);
                        updateRecipeCardSpan(card);
                        updateAllRecipeCardSpans();
                    });
                })
                .catch(error => {
                    console.error('Error fetching recipe:', error);
                    details.innerHTML = '<p class="text-sm text-text-muted">Unable to load recipe details.</p>';
                });
        }

        function toggleRecipeCard(card) {
            if (!card) {
                return;
            }
            if (card === activeCard) {
                collapseCard(card);
                return;
            }
            if (activeCard) {
                collapseCard(activeCard);
            }
            activeCard = card;
            currentDrink = card.dataset.drink;
            card.classList.add('ring-2', 'ring-logo');
            card.classList.add('is-active');
            const toggle = card.querySelector('.recipe-card-toggle');
            if (toggle) {
                toggle.setAttribute('aria-expanded', 'true');
            }
            const details = card.querySelector('.recipe-card-details');
            if (details) {
                details.classList.remove('hidden');
                if (card.dataset.loaded !== 'true') {
                    loadRecipeDetails(card);
                }
            }
            requestAnimationFrame(() => {
                syncExpandedCardSpan(card);
                updateRecipeCardSpan(card);
                updateAllRecipeCardSpans();
            });
        }

        function initializeRecipeCards() {
            const cards = document.querySelectorAll('.recipe-card');
            cards.forEach((card) => {
                card.addEventListener('click', (event) => {
                    if (
                        event.target.closest('.recipe-card-toggle') ||
                        event.target.closest('.recipe-card-edit') ||
                        event.target.closest('.recipe-card-delete') ||
                        event.target.closest('a, input, select, textarea, button')
                    ) {
                        return;
                    }
                    toggleRecipeCard(card);
                });
            });

            const toggles = document.querySelectorAll('.recipe-card-toggle');
            toggles.forEach(toggle => {
                toggle.setAttribute('aria-expanded', 'false');
                toggle.addEventListener('click', (event) => {
                    event.stopPropagation();
                    const card = toggle.closest('.recipe-card');
                    toggleRecipeCard(card);
                });
            });
        }
        window.applyRecipeFilters = applyRecipeFilters;
        window.filterCards = applyRecipeFilters;
        window.resetRecipeFilters = resetRecipeFilters;
        function openAddModal() {
            const modal = document.getElementById('add-modal');
            modal.classList.remove('hidden');
            modal.style.display = 'flex';
            ingredientCount = 1;
            const list = document.getElementById('add-ingredients-list');
            if (list) {
                list.innerHTML = makeIngredientRowMarkup(0);
            }
        }

        function closeAddModal() {
            const modal = document.getElementById('add-modal');
            const form = document.getElementById('add-recipe-form');
            if (form) {
                form.reset();
            }
            modal.style.display = 'none';
            modal.classList.add('hidden');
            ingredientCount = 1;
            const list = document.getElementById('add-ingredients-list');
            if (list) {
                list.innerHTML = makeIngredientRowMarkup(0);
            }
        }

        function addIngredient(modalType) {
            const list = document.getElementById(modalType + '-ingredients-list');
            const count = (modalType === 'add' ? ingredientCount++ : editIngredientCount++);
            if (!list) {
                return;
            }
            if (modalType === 'add') {
                list.insertAdjacentHTML('afterbegin', makeIngredientRowMarkup(count));
            } else {
                list.insertAdjacentHTML('beforeend', makeIngredientRowMarkup(count));
            }
            const newRow = modalType === 'add' ? list.firstElementChild : list.lastElementChild;
            if (!newRow) {
                return;
            }
            const ingredientInput = newRow.querySelector(`input[name="ingredient_${count}"]`);
            if (ingredientInput) {
                ingredientInput.focus();
            }
            newRow.classList.add('ring-1', 'ring-logo/50');
            window.setTimeout(() => {
                newRow.classList.remove('ring-1', 'ring-logo/50');
            }, 800);
        }

        function removeIngredient(button) {
            button.parentElement.remove();
        }

        function filterIngredients(input, index) {
            if (!input) {
                return;
            }
            const field = input.closest('.ingredient-field');
            const dropdown = field ? field.querySelector('.ingredient-dropdown') : null;
            if (!dropdown) {
                console.error('Invalid dropdown element for input:', input);
                return;
            }

            const rawValue = input.value.trim();
            const value = rawValue.toLowerCase();
            dropdown.innerHTML = '';
            dropdown.classList.add('hidden');
            dropdown.classList.remove('ingredient-dropdown--above');
            dropdown.style.maxHeight = '';

            if (!value) {
                dropdown.classList.add('hidden');
                dropdown.style.maxHeight = '';
                return;
            }

            const options = Array.isArray(allIngredientOptions) ? allIngredientOptions : [];
            const matches = options.filter((opt) => opt.toLowerCase().includes(value));
            const fragment = document.createDocumentFragment();

            matches.forEach((opt) => {
                const option = document.createElement('button');
                option.type = 'button';
                option.className = 'ingredient-option';
                option.textContent = opt;
                option.setAttribute('role', 'option');
                option.addEventListener('click', () => {
                    input.value = opt;
                    dropdown.classList.add('hidden');
                    dropdown.innerHTML = '';
                    dropdown.classList.remove('ingredient-dropdown--above');
                    dropdown.style.maxHeight = '';
                });
                fragment.appendChild(option);
            });

            if (!matches.length) {
                const empty = document.createElement('div');
                empty.className = 'ingredient-option-empty';
                empty.textContent = 'No matches found';
                fragment.appendChild(empty);
            }

            const hasExactMatch = matches.some((opt) => opt.toLowerCase() === value);
            if (rawValue && !hasExactMatch) {
                const addButton = document.createElement('button');
                addButton.type = 'button';
                addButton.className = 'ingredient-option ingredient-option-add';
                addButton.textContent = `Add "${rawValue}"`;
                addButton.addEventListener('click', (event) => {
                    event.preventDefault();
                    openAddIngredientModal(rawValue, input, index);
                    dropdown.classList.add('hidden');
                    dropdown.innerHTML = '';
                    dropdown.classList.remove('ingredient-dropdown--above');
                    dropdown.style.maxHeight = '';
                });
                fragment.appendChild(addButton);
            }

            dropdown.appendChild(fragment);

            if (!dropdown.childElementCount) {
                dropdown.classList.add('hidden');
                dropdown.style.maxHeight = '';
                return;
            }

            dropdown.classList.remove('hidden');
            dropdown.scrollTop = 0;

            window.requestAnimationFrame(() => {
                const modalBody = dropdown.closest('.modal-body');
                if (!modalBody) {
                    dropdown.style.maxHeight = '';
                    return;
                }
                const bodyRect = modalBody.getBoundingClientRect();
                const fieldRect = field.getBoundingClientRect();
                const dropdownHeight = dropdown.scrollHeight;
                const gutter = 8;
                const spaceBelow = Math.max(0, bodyRect.bottom - fieldRect.bottom - gutter);
                const spaceAbove = Math.max(0, fieldRect.top - bodyRect.top - gutter);
                const shouldOpenUp = dropdownHeight > spaceBelow && spaceAbove > spaceBelow;
                dropdown.classList.toggle('ingredient-dropdown--above', shouldOpenUp);
                const availableSpace = shouldOpenUp ? spaceAbove : spaceBelow;
                if (availableSpace > 0) {
                    dropdown.style.maxHeight = `${Math.min(dropdownHeight, availableSpace)}px`;
                } else {
                    dropdown.style.maxHeight = '';
                }
            });

            const closeOnOutsideClick = (event) => {
                if (field && !field.contains(event.target)) {
                    dropdown.classList.add('hidden');
                    dropdown.innerHTML = '';
                    dropdown.classList.remove('ingredient-dropdown--above');
                    dropdown.style.maxHeight = '';
                    document.removeEventListener('click', closeOnOutsideClick);
                }
            };

            window.setTimeout(() => {
                document.addEventListener('click', closeOnOutsideClick);
            }, 0);
        }

        function openAddIngredientModal(value, input, index) {
            const modal = document.getElementById('add-ingredient-modal');
            const nameInput = document.getElementById('new-ingredient-name');
            const form = document.getElementById('add-ingredient-form');
            nameInput.value = value;
            form.currentIngredientInput = input;
            form.dataset.index = index;
            modal.classList.remove('hidden');
            modal.style.display = 'flex';
        }

        function closeAddIngredientModal() {
            const modal = document.getElementById('add-ingredient-modal');
            const form = document.getElementById('add-ingredient-form');
            if (modal) {
                modal.classList.add('hidden');
                modal.style.display = 'none';
            }
            if (form) {
                form.reset();
                form.currentIngredientInput = null;
            }
            const subcatSelect = document.getElementById('new-ingredient-subcategory');
            if (subcatSelect) {
                subcatSelect.innerHTML = '<option value=\"\">None</option>';
            }
        }

        function openEditModal(drink) {
            fetch(`/recipe/${encodeURIComponent(drink)}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    const editModal = document.getElementById('edit-modal');
                    if (editModal) {
                        editModal.classList.remove('hidden');
                        editModal.style.display = 'flex';
                    }
                    document.getElementById('edit-original-drink').value = data.name || '';
                    document.getElementById('edit-drink').value = data.name || '';
                    const baseSpiritInput = document.getElementById('edit-base_spirit-input');
                    if (baseSpiritInput) {
                        baseSpiritInput.value = data.base_spirit || '';
                    }
                    document.getElementById('edit-base_spirit').value = data.base_spirit || '';
                    document.getElementById('edit-glass').value = data.glass || '';
                    document.getElementById('edit-garnish').value = data.garnish || '';
                    document.getElementById('edit-method').value = data.method || '';
                    const iceInput = document.getElementById('edit_ice');
                    if (iceInput) {
                        iceInput.value = data.ice || '';
                    }
                    document.getElementById('edit-notes').value = data.notes || '';

                    const ingredientsList = document.getElementById('edit-ingredients-list');
                    ingredientsList.innerHTML = '';
                    editIngredientCount = 0;

                    if (data.ingredients && Array.isArray(data.ingredients)) {
                        data.ingredients.forEach((ing, index) => {
                            ingredientsList.insertAdjacentHTML('beforeend', makeIngredientRowMarkup(index));
                            const row = ingredientsList.lastElementChild;
                            if (!row) {
                                return;
                            }
                            const ingredientInput = row.querySelector(`input[name="ingredient_${index}"]`);
                            const quantityInput = row.querySelector(`input[name="quantity_${index}"]`);
                            const unitSelect = row.querySelector(`select[name="unit_${index}"]`);
                            if (ingredientInput) {
                                ingredientInput.value = ing.ingredient || '';
                            }
                            if (quantityInput) {
                                quantityInput.value = ing.quantity || '';
                            }
                            if (unitSelect) {
                                unitSelect.value = ing.unit || 'oz';
                            }
                            editIngredientCount = index + 1;
                        });
                    } else {
                        console.error('Invalid ingredients data:', data.ingredients);
                    }
                })
                .catch(error => {
                    console.error('Error fetching recipe:', error);
                    alert('Error fetching recipe details. Check the console for details.');
                });
        }

        function closeEditModal() {
            const modal = document.getElementById('edit-modal');
            modal.style.display = 'none';
            modal.classList.add('hidden');
            const form = document.getElementById('edit-recipe-form');
            form.reset();
            document.getElementById('edit-ingredients-list').innerHTML = '';
            editIngredientCount = 0;
        }

        function saveEdit() {
            const form = document.getElementById('edit-recipe-form');
            const iceInput = form.querySelector('#edit_ice');
            const data = {
                original_drink: form.querySelector('#edit-original-drink').value,
                drink: form.querySelector('#edit-drink').value,
                glass: form.querySelector('#edit-glass').value,
                garnish: form.querySelector('#edit-garnish').value,
                method: form.querySelector('#edit-method').value,
                ice: iceInput ? iceInput.value : '',
                notes: form.querySelector('#edit-notes').value,
                base_spirit: form.querySelector('#edit-base_spirit').value,
                ingredients: []
            };

            const ingredientRows = form.querySelectorAll('#edit-ingredients-list .ingredient-row');
            ingredientRows.forEach(row => {
                const ingredient = row.querySelector(`input[name^="ingredient_"]`).value;
                const quantity = row.querySelector(`input[name^="quantity_"]`).value;
                const unit = row.querySelector(`select[name^="unit_"]`).value;
                if (ingredient && quantity && unit) {
                    data.ingredients.push({ ingredient, quantity, unit });
                }
            });

            const url = `/recipe/edit_recipe/${encodeURIComponent(data.original_drink)}`;

            fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            })
                .then(response => {
                    if (!response.ok) {
                        return response.text().then(text => {
                            throw new Error(`HTTP error! Status: ${response.status}, Response: ${text}`);
                        });
                    }
                    return response.json();
                })
                .then(result => {
                    if (result.success) {
                        showToast("Recipe updated successfully!");
                        closeEditModal();
                        sessionStorage.setItem('selectedDrink', data.drink);
                        setTimeout(() => location.reload(), 1000);
                    } else {
                        showToast(result.message || "Failed to update recipe.");
                        console.error('Update failed:', result.message);
                    }
                })
                .catch(error => {
                    console.error('Fetch error:', error);
                    showToast("Error saving recipe. See console.");
                });
        }

        function deleteRecipe(drink) {
            fetch(`/recipe/delete_recipe/${encodeURIComponent(drink)}`, {
                method: 'DELETE'
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    closeDeleteModal();
                    location.reload();
                })
                .catch(error => {
                    console.error('Error deleting recipe:', error);
                    alert('Error deleting recipe: ' + error.message);
                    closeDeleteModal();
                });
        }

        function closeDeleteModal() {
            const modal = document.getElementById('delete-modal');
            if (!modal) {
                return;
            }
            modal.style.display = 'none';
            modal.classList.add('hidden');
        }

        function filterBaseSpirit(modalType) {
            const input = document.getElementById(`${modalType}-base_spirit-input`);
            const select = document.getElementById(`${modalType}-base_spirit`);
            const field = input ? input.closest('.base-spirit-field') : null;
            const dropdown = field ? field.querySelector('.ingredient-dropdown') : null;

            if (!input || !select || !dropdown) {
                console.error(`Missing elements for ${modalType}-base_spirit:`, { input, select, dropdown });
                return;
            }

            const rawValue = input.value.trim();
            const value = rawValue.toLowerCase();
            dropdown.innerHTML = '';
            dropdown.classList.add('hidden');
            dropdown.classList.remove('ingredient-dropdown--above');
            dropdown.style.maxHeight = '';

            if (!value) {
                select.value = '';
                return;
            }

            const options = Array.from(select.options).slice(1);
            const matches = options.filter((option) => {
                const optionValue = option.value.toLowerCase();
                const optionText = option.text.toLowerCase();
                return optionValue.includes(value) || optionText.includes(value);
            });

            const fragment = document.createDocumentFragment();

            matches.forEach((option) => {
                const button = document.createElement('button');
                button.type = 'button';
                button.className = 'ingredient-option';
                button.textContent = option.text;
                button.setAttribute('role', 'option');
                button.addEventListener('click', () => {
                    input.value = option.value;
                    select.value = option.value;
                    dropdown.classList.add('hidden');
                    dropdown.innerHTML = '';
                    dropdown.classList.remove('ingredient-dropdown--above');
                    dropdown.style.maxHeight = '';
                });
                fragment.appendChild(button);
            });

            if (!matches.length) {
                const emptyState = document.createElement('div');
                emptyState.className = 'ingredient-option-empty';
                emptyState.textContent = 'No spirits found';
                fragment.appendChild(emptyState);
            }

            dropdown.appendChild(fragment);

            if (!dropdown.childElementCount) {
                dropdown.classList.add('hidden');
                dropdown.style.maxHeight = '';
                return;
            }

            dropdown.classList.remove('hidden');
            dropdown.scrollTop = 0;

            window.requestAnimationFrame(() => {
                const modalBody = dropdown.closest('.modal-body');
                if (!modalBody || !field) {
                    dropdown.style.maxHeight = '';
                    return;
                }
                const fieldRect = field.getBoundingClientRect();
                const bodyRect = modalBody.getBoundingClientRect();
                const dropdownHeight = dropdown.scrollHeight;
                const gutter = 8;
                const spaceBelow = Math.max(0, bodyRect.bottom - fieldRect.bottom - gutter);
                const spaceAbove = Math.max(0, fieldRect.top - bodyRect.top - gutter);
                const shouldOpenUp = dropdownHeight > spaceBelow && spaceAbove > spaceBelow;
                dropdown.classList.toggle('ingredient-dropdown--above', shouldOpenUp);
                const availableSpace = shouldOpenUp ? spaceAbove : spaceBelow;
                dropdown.style.maxHeight = availableSpace > 0
                    ? `${Math.min(dropdownHeight, availableSpace)}px`
                    : '';
            });

            const closeOnOutsideClick = (event) => {
                if (field && !field.contains(event.target)) {
                    dropdown.classList.add('hidden');
                    dropdown.innerHTML = '';
                    dropdown.classList.remove('ingredient-dropdown--above');
                    dropdown.style.maxHeight = '';
                    document.removeEventListener('click', closeOnOutsideClick);
                }
            };

            window.setTimeout(() => {
                document.addEventListener('click', closeOnOutsideClick);
            }, 0);
        }
    </script>
    </div>

{% endblock %}

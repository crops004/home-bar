{% extends "base.html" %}
{% block title %}Recipe Collection{% endblock %}
{% block content %}
    <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
        <h1 class="text-3xl font-semibold text-text-normal">Recipe Collection</h1>
        <button
            type="button"
            onclick="openAddModal()"
            class="inline-flex items-center gap-2 rounded-full bg-logo px-5 py-2 text-sm font-medium text-light-text-normal hover:ring-2 hover:ring-logo transition"
        >
            <span class="text-xl leading-none">+</span>
            Add New Recipe
        </button>
    </div>

    <div class="mt-6 flex flex-wrap gap-4 items-end bg-background-mid/40 border border-border rounded-2xl p-4">
        <div class="flex flex-col gap-1">
            <label for="filter-name" class="text-xs uppercase tracking-wide text-text-muted">Search Name</label>
            <input
                type="text"
                id="filter-name"
                oninput="filterCards()"
                placeholder="e.g. Negroni"
                class="rounded-lg border border-border bg-background-light px-3 py-2 text-sm text-text-normal focus:outline-none focus:ring-2 focus:ring-logo"
            >
        </div>
        <div class="flex flex-col gap-1">
            <label for="filter-spirit" class="text-xs uppercase tracking-wide text-text-muted">Base Spirit</label>
            <input
                type="text"
                id="filter-spirit"
                oninput="filterCards()"
                placeholder="e.g. Gin"
                class="rounded-lg border border-border bg-background-light px-3 py-2 text-sm text-text-normal focus:outline-none focus:ring-2 focus:ring-logo"
            >
        </div>
        <button
            type="button"
            onclick="resetRecipeFilters()"
            class="ml-auto inline-flex items-center gap-2 rounded-full border border-border px-4 py-2 text-sm text-text-normal hover:bg-background-light transition"
        >
            Clear Filters
        </button>
    </div>

    <!-- Recipe Cards -->
    {% if all_recipes %}
    <div id="recipes-container" class="mt-6 space-y-8">
        {% for group in all_recipes | groupby('base_spirit_category') %}
        {% set spirit = ((group.grouper or '') | trim) | default('Unknown', true) %}
        {% set spirit_key = spirit.lower() %}
        {% set group_recipes = group.list | sort(attribute='drink', case_sensitive=False) %}
        <section class="recipe-group space-y-4" data-spirit="{{ spirit_key }}">
            <h2 class="text-sm font-semibold uppercase tracking-wide text-text-muted">{{ spirit }}</h2>
            <div class="grid gap-4 sm:grid-cols-2 xl:grid-cols-3">
                {% for recipe in group_recipes %}
                {% set summary = (recipe.ingredient_summary | default('', true)) | trim %}
                <article
                    class="recipe-card bg-background-mid border border-border rounded-2xl shadow-lg overflow-hidden transition transform hover:-translate-y-1 hover:shadow-xl"
                    data-drink="{{ recipe.drink|escape }}"
                    data-base-spirit="{{ recipe.base_spirit|default('', true)|escape }}"
                    data-base-category="{{ spirit|escape }}"
                >
                    <button
                        type="button"
                        aria-expanded="false"
                        class="recipe-card-toggle w-full text-left p-4 flex flex-col gap-3 focus:outline-none focus-visible:ring-2 focus-visible:ring-logo"
                    >
                        <header class="flex justify-between items-start gap-3">
                            <h3 class="text-lg font-semibold text-text-normal truncate">{{ recipe.drink }}</h3>
                        </header>
                        <p class="recipe-summary text-xs uppercase tracking-wide text-text-muted whitespace-nowrap overflow-hidden text-ellipsis" title="{{ summary or 'No spirits listed' }}">
                            {{ summary or 'No spirits listed' }}
                        </p>
                    </button>
                    <div class="recipe-card-details hidden border-t border-border bg-background-dark p-4 text-sm text-text-normal">
                        <p class="text-text-muted">Select to load details.</p>
                    </div>
                </article>
                {% endfor %}
            </div>
        </section>
        {% endfor %}
    </div>
    <p id="recipes-empty" class="mt-6 hidden text-sm text-text-muted">No recipes match your filters.</p>
    {% else %}
    <p class="mt-6 text-text-muted">No recipes yet. Use the button above to add your first cocktail.</p>
    {% endif %}

    <!-- Add Recipe Modal -->
    <div id="add-modal" class="modal-backdrop hidden">
        <div class="modal-panel">
            <div class="modal-header">
                <h2 class="text-xl font-semibold text-text-normal">Add New Recipe</h2>
                <button type="button" onclick="closeAddModal()" class="text-text-muted hover:text-text-normal text-2xl leading-none">&times;</button>
            </div>
            <form id="add-recipe-form" method="post" class="flex flex-col max-h-[80vh]">
                <div class="modal-body space-y-4">
                    <div class="grid gap-4 sm:grid-cols-2">
                        <label class="flex flex-col gap-1 text-sm">
                            <span class="modal-label">Drink Name</span>
                            <input type="text" id="add-drink" name="drink" required class="modal-input" />
                        </label>
                        <label class="flex flex-col gap-1 text-sm">
                            <span class="modal-label">Base Spirit</span>
                            <div class="base-spirit-field relative w-full">
                                <input type="text" id="add-base_spirit-input" placeholder="Type to filter base spirits..." oninput="filterBaseSpirit('add')" class="modal-input w-full" autocomplete="off" />
                                <div id="add-base_spirit-dropdown" class="ingredient-dropdown hidden" role="listbox"></div>
                            </div>
                            <select id="add-base_spirit" name="base_spirit" class="hidden">
                                <option value="">None</option>
                                {% for cat in lists['categories'] %}
                                    <option value="{{ cat }}">{{ cat }}</option>
                                {% endfor %}
                                {% for cat, subs in lists['subcategories'].items() %}
                                    {% for sub in subs %}
                                        <option value="{{ sub }}">{{ sub }} ({{ cat }})</option>
                                    {% endfor %}
                                {% endfor %}
                            </select>
                        </label>
                        <label class="flex flex-col gap-1 text-sm">
                            <span class="modal-label">Glass</span>
                            <select id="add-glass" name="glass" class="modal-input">
                                <option value="">None</option>
                                {% for glass in lists['glass_types'] %}
                                    <option value="{{ glass }}">{{ glass }}</option>
                                {% endfor %}
                            </select>
                        </label>
                        <label class="flex flex-col gap-1 text-sm">
                            <span class="modal-label">Garnish</span>
                            <input type="text" id="add-garnish" name="garnish" class="modal-input" />
                        </label>
                        <label class="flex flex-col gap-1 text-sm">
                            <span class="modal-label">Method</span>
                            <select id="add-method" name="method" class="modal-input">
                                <option value="">None</option>
                                {% for method in lists['methods'] %}
                                    <option value="{{ method }}">{{ method }}</option>
                                {% endfor %}
                            </select>
                        </label>
                        <label class="flex flex-col gap-1 text-sm">
                            <span class="modal-label">Ice</span>
                            <select id="add_ice" name="Ice" class="modal-input">
                                <option value="">None</option>
                                {% for ice in lists['ice_options'] %}
                                    <option value="{{ ice }}">{{ ice }}</option>
                                {% endfor %}
                            </select>
                        </label>
                    </div>
                    <label class="flex flex-col gap-1 text-sm">
                        <span class="modal-label">Notes</span>
                        <textarea id="add-notes" name="notes" rows="3" class="modal-input"></textarea>
                    </label>

                    <div class="space-y-2">
                        <div class="flex items-center justify-between">
                            <h3 class="text-sm font-semibold uppercase tracking-wide text-text-muted">Ingredients</h3>
                            <button type="button" onclick="addIngredient('add')" class="modal-button-secondary text-xs">Add Ingredient</button>
                        </div>
                        <div id="add-ingredients-list" class="space-y-2">
                            <div class="ingredient-row flex flex-wrap items-center gap-2 rounded-lg border border-border bg-background-light/80 px-3 py-2">
                                <div class="ingredient-field relative flex-1 min-w-[12rem]">
                                    <input type="text" name="ingredient_0" class="ingredient-input modal-input w-full" placeholder="Type to search ingredients..." oninput="filterIngredients(this, 0)" autocomplete="off" />
                                    <div class="ingredient-dropdown hidden" role="listbox"></div>
                                </div>
                                <input type="text" name="quantity_0" placeholder="Qty" class="quantity-input modal-input w-20" />
                                <select name="unit_0" class="unit-select modal-input">
                                    {% for unit in lists['units'] %}
                                        <option value="{{ unit }}" {% if unit == 'oz' %}selected{% endif %}>{{ unit }}</option>
                                    {% endfor %}
                                </select>
                                <button type="button" onclick="removeIngredient(this)" class="ingredient-remove-btn rounded-full bg-red-600 px-3 py-1 text-xs text-white hover:bg-red-500 transition">Remove</button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" onclick="closeAddModal()" class="modal-button-secondary">Cancel</button>
                    <button type="submit" class="modal-button-primary">Save Recipe</button>
                </div>
            </form>
        </div>
    </div>    <!-- Edit Recipe Modal -->
    <div id="edit-modal" class="modal-backdrop hidden">
        <div class="modal-panel">
            <div class="modal-header">
                <h2 class="text-xl font-semibold text-text-normal">Edit Recipe</h2>
                <button type="button" onclick="closeEditModal()" class="text-text-muted hover:text-text-normal text-2xl leading-none">&times;</button>
            </div>
            <form id="edit-recipe-form" class="flex flex-col max-h-[80vh]">
                <div class="modal-body space-y-4">
                    <input type="hidden" id="edit-original-drink" name="original_drink">
                    <div class="grid gap-4 sm:grid-cols-2">
                        <label class="flex flex-col gap-1 text-sm">
                            <span class="modal-label">Drink Name</span>
                            <input type="text" id="edit-drink" name="drink" required class="modal-input" />
                        </label>
                        <label class="flex flex-col gap-1 text-sm">
                            <span class="modal-label">Base Spirit</span>
                            <div class="base-spirit-field relative w-full">
                                <input type="text" id="edit-base_spirit-input" placeholder="Type to filter base spirits..." oninput="filterBaseSpirit('edit')" class="modal-input w-full" autocomplete="off" />
                                <div id="edit-base_spirit-dropdown" class="ingredient-dropdown hidden" role="listbox"></div>
                            </div>
                            <select id="edit-base_spirit" name="base_spirit" class="hidden">
                                <option value="">None</option>
                                {% for cat in lists['categories'] %}
                                    <option value="{{ cat }}">{{ cat }}</option>
                                {% endfor %}
                                {% for cat, subs in lists['subcategories'].items() %}
                                    {% for sub in subs %}
                                        <option value="{{ sub }}">{{ sub }} ({{ cat }})</option>
                                    {% endfor %}
                                {% endfor %}
                            </select>
                        </label>
                        <label class="flex flex-col gap-1 text-sm">
                            <span class="modal-label">Glass</span>
                            <select id="edit-glass" name="glass" class="modal-input">
                                <option value="">None</option>
                                {% for glass in lists['glass_types'] %}
                                    <option value="{{ glass }}">{{ glass }}</option>
                                {% endfor %}
                            </select>
                        </label>
                        <label class="flex flex-col gap-1 text-sm">
                            <span class="modal-label">Garnish</span>
                            <input type="text" id="edit-garnish" name="garnish" class="modal-input" />
                        </label>
                        <label class="flex flex-col gap-1 text-sm">
                            <span class="modal-label">Method</span>
                            <select id="edit-method" name="method" class="modal-input">
                                <option value="">None</option>
                                {% for method in lists['methods'] %}
                                    <option value="{{ method }}">{{ method }}</option>
                                {% endfor %}
                            </select>
                        </label>
                        <label class="flex flex-col gap-1 text-sm">
                            <span class="modal-label">Ice</span>
                            <select id="edit_ice" name="Ice" class="modal-input">
                                <option value="">None</option>
                                {% for ice in lists['ice_options'] %}
                                    <option value="{{ ice }}">{{ ice }}</option>
                                {% endfor %}
                            </select>
                        </label>
                    </div>
                    <label class="flex flex-col gap-1 text-sm">
                        <span class="modal-label">Notes</span>
                        <textarea id="edit-notes" name="notes" rows="3" class="modal-input"></textarea>
                    </label>

                    <div class="space-y-2">
                        <div class="flex items-center justify-between">
                            <h3 class="text-sm font-semibold uppercase tracking-wide text-text-muted">Ingredients</h3>
                            <button type="button" onclick="addIngredient('edit')" class="modal-button-secondary text-xs">Add Ingredient</button>
                        </div>
                        <div id="edit-ingredients-list" class="space-y-2"></div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" onclick="closeEditModal()" class="modal-button-secondary">Cancel</button>
                    <button type="button" onclick="saveEdit()" class="modal-button-primary">Save Changes</button>
                </div>
            </form>
        </div>
    </div>    <div id="add-ingredient-modal" class="modal-backdrop hidden">
        <div class="modal-panel max-w-lg">
            <div class="modal-header">
                <h2 class="text-xl font-semibold text-text-normal">Add New Ingredient</h2>
                <button type="button" onclick="closeAddIngredientModal()" class="text-text-muted hover:text-text-normal text-2xl leading-none">&times;</button>
            </div>
            <form id="add-ingredient-form" class="flex flex-col max-h-[70vh]">
                <div class="modal-body space-y-4 text-sm">
                    <label class="flex flex-col gap-1">
                        <span class="modal-label">Ingredient Name</span>
                        <input type="text" id="new-ingredient-name" name="name" placeholder="Ingredient Name" required readonly class="modal-input" />
                    </label>
                    <label class="flex flex-col gap-1">
                        <span class="modal-label">Category</span>
                        <select name="category" id="new-ingredient-category" required class="modal-input">
                            <option value="" disabled selected>Select Category</option>
                            {% for category in lists['categories'] %}
                                <option value="{{ category }}">{{ category }}</option>
                            {% endfor %}
                        </select>
                    </label>
                    <label class="flex flex-col gap-1">
                        <span class="modal-label">Subcategory</span>
                        <select name="sub_category" id="new-ingredient-subcategory" class="modal-input">
                            <option value="">None</option>
                        </select>
                    </label>
                </div>
                <div class="modal-footer">
                    <button type="button" onclick="closeAddIngredientModal()" class="modal-button-secondary">Cancel</button>
                    <button type="submit" class="modal-button-primary">Add Ingredient</button>
                </div>
            </form>
        </div>
    </div>    <!-- Delete Confirmation Modal -->
    <div id="delete-modal" class="modal-backdrop hidden">
        <div class="modal-panel max-w-sm">
            <div class="modal-header">
                <h2 class="text-lg font-semibold text-text-normal">Delete Recipe</h2>
                <button type="button" onclick="closeDeleteModal()" class="text-text-muted hover:text-text-normal text-2xl leading-none">&times;</button>
            </div>
            <div class="modal-body space-y-4">
                <p id="delete-modal-message" class="text-sm text-text-normal"></p>
            </div>
            <div class="modal-footer">
                <button id="cancel-delete" type="button" class="modal-button-secondary">Cancel</button>
                <button id="confirm-delete" type="button" class="modal-button-danger">Delete</button>
            </div>
        </div>
    </div>

    <div id="recipes-data"
         class="hidden"
         data-categories='{{ lists["categories"] | tojson }}'
         data-subcategories='{{ lists["subcategories"] | tojson }}'
         data-spirit-categories='{{ spirit_categories | tojson }}'></div>

    <!-- Hidden select for units -->
    <script>
        let ingredientCount = 1;
        let editIngredientCount = 0;
        let currentDrink = null;
        let possibleIngredients = [];
        let allIngredientOptions = []; // Initialize as array

        const recipesDataElement = document.getElementById('recipes-data');
        const rawCategories = recipesDataElement?.dataset.categories || '[]';
        const rawSubcategories = recipesDataElement?.dataset.subcategories || '{}';
        const rawSpiritCategories = recipesDataElement?.dataset.spiritCategories || '[]';

        const baseSpiritCategoryLookup = (() => {
            const lookup = {};
            let subcategories = {};
            let categories = [];
            try {
                subcategories = JSON.parse(rawSubcategories);
            } catch (error) {
                console.error('Unable to parse subcategory data:', error);
            }
            Object.entries(subcategories).forEach(([category, subs]) => {
                const loweredCategory = (category || '').toLowerCase();
                if (loweredCategory) {
                    lookup[loweredCategory] = category;
                }
                (subs || []).forEach((sub) => {
                    const loweredSub = (sub || '').toLowerCase();
                    if (loweredSub) {
                        lookup[loweredSub] = category;
                    }
                });
            });

            try {
                categories = JSON.parse(rawCategories);
            } catch (error) {
                console.error('Unable to parse category data:', error);
            }
            (categories || []).forEach((category) => {
                const lowered = (category || '').toLowerCase();
                if (lowered && !lookup[lowered]) {
                    lookup[lowered] = category;
                }
            });
            return lookup;
        })();

        const spiritCategorySet = (() => {
            try {
                return new Set(JSON.parse(rawSpiritCategories).map((category) => String(category || '').toLowerCase()));
            } catch (error) {
                console.error('Unable to parse spirit categories:', error);
                return new Set();
            }
        })();

        function resolveBaseCategory(value) {
            const normalized = typeof value === 'string' ? value.trim() : '';
            if (!normalized) {
                return 'Unknown';
            }
            const match = baseSpiritCategoryLookup[normalized.toLowerCase()];
            if (match) {
                return match;
            }
            return normalized;
        }

        function summarizeSpiritIngredients(ingredients) {
            if (!Array.isArray(ingredients)) {
                return [];
            }
            const summary = [];
            const seen = new Set();
            ingredients.forEach((item) => {
                if (!item) {
                    return;
                }
                const name = (item.ingredient || '').trim();
                if (!name) {
                    return;
                }
                const candidates = [
                    item.sub_category || '',
                    item.category || '',
                ];
                let isSpirit = false;
                for (const candidate of candidates) {
                    if (!candidate) {
                        continue;
                    }
                    const resolved = resolveBaseCategory(candidate);
                    if (spiritCategorySet.has(resolved.toLowerCase())) {
                        isSpirit = true;
                        break;
                    }
                }
                if (!isSpirit) {
                    const resolvedFromName = resolveBaseCategory(name);
                    if (spiritCategorySet.has(resolvedFromName.toLowerCase())) {
                        isSpirit = true;
                    }
                }
                if (isSpirit && !seen.has(name)) {
                    summary.push(name);
                    seen.add(name);
                }
            });
            return summary;
        }

        const makeIngredientRowMarkup = (index) => `
            <div class="ingredient-row flex flex-wrap items-center gap-2 rounded-lg border border-border bg-background-light/80 px-3 py-2">
                <div class="ingredient-field relative flex-1 min-w-[12rem]">
                    <input
                        type="text"
                        name="ingredient_${index}"
                        class="ingredient-input modal-input w-full"
                        placeholder="Type to search ingredients..."
                        autocomplete="off"
                        oninput="filterIngredients(this, ${index})"
                    />
                    <div class="ingredient-dropdown hidden" role="listbox"></div>
                </div>
                <input type="text" name="quantity_${index}" placeholder="Qty" class="quantity-input modal-input w-20" />
                <select name="unit_${index}" class="unit-select modal-input">
                    {% for unit in lists['units'] %}
                        <option value="{{ unit }}" {% if unit == 'oz' %}selected{% endif %}>{{ unit }}</option>
                    {% endfor %}
                </select>
                <button type="button" onclick="removeIngredient(this)" class="ingredient-remove-btn rounded-full bg-red-600 px-3 py-1 text-xs text-white hover:bg-red-500 transition">Remove</button>
            </div>
        `;

        // Fetch the master list of ingredient names, categories, and subcategories on page load
        document.addEventListener('DOMContentLoaded', function() {
            fetch('/possible-ingredients-json')
                .then(response => {
                    if (!response.ok) {
                        return response.text().then(text => {
                        });
                    }
                    return response.json();
                })
                .then(data => {
                    possibleIngredients = data; // Array of all unique names, categories, and subcategories
                    // Use the data directly as allIngredientOptions, ensuring uniqueness with Set
                    allIngredientOptions = [...new Set(possibleIngredients)].sort(); // Remove duplicates and sort
                })
                .catch(error => {
                    console.error('Error fetching possible ingredients:', error);
                    allIngredientOptions = []; // Fallback to empty array if fetch fails
                });

            // Delete modal handlers
            document.getElementById('confirm-delete').addEventListener('click', function() {
                if (currentDrink) {
                    deleteRecipe(currentDrink);
                }
            });
            document.getElementById('cancel-delete').addEventListener('click', function() {
                closeDeleteModal();
            });

            initializeRecipeCards();
            filterCards();

            // Reselect the drink after edit
            const selectedDrink = sessionStorage.getItem('selectedDrink');
            if (selectedDrink) {
                const escapeValue = window.CSS && window.CSS.escape
                    ? window.CSS.escape(selectedDrink)
                    : selectedDrink.replace(/(["\\])/g, '\\$1');
                const card = document.querySelector(`.recipe-card[data-drink=\"${escapeValue}\"]`);
                if (card) {
                    toggleRecipeCard(card);
                }
                sessionStorage.removeItem('selectedDrink'); // Clear after use
            }

            // Handle Add Ingredient modal form submission
            const addIngredientForm = document.getElementById('add-ingredient-form');
            if (addIngredientForm) {
                addIngredientForm.addEventListener('submit', function(e) {
                    e.preventDefault();
                    const formData = new FormData(this);
                    fetch('/possible-ingredients', {
                        method: 'POST',
                        body: formData
                    })
                        .then(response => {
                            if (!response.ok) {
                            }
                            return response.text();
                        })
                        .then(() => {
                            // Update possibleIngredients and allIngredientOptions
                            const newName = formData.get('name').trim();
                            const newCategory = formData.get('category').trim();
                            const newSubCategory = formData.get('sub_category') || null;
                            possibleIngredients.push(newName);
                            if (newCategory) possibleIngredients.push(newCategory);
                            if (newSubCategory) possibleIngredients.push(newSubCategory);
                            allIngredientOptions = [...new Set(possibleIngredients)].sort();

                            // Update the input field
                            const targetInput = addIngredientForm.currentIngredientInput;
                            if (targetInput instanceof HTMLInputElement) {
                                targetInput.value = newName;
                                const dropdown = targetInput.closest('.ingredient-field')?.querySelector('.ingredient-dropdown');
                            if (dropdown) {
                                dropdown.classList.add('hidden');
                                dropdown.innerHTML = '';
                                dropdown.classList.remove('ingredient-dropdown--above');
                                dropdown.style.maxHeight = '';
                            }
                            }
                            addIngredientForm.currentIngredientInput = null;
                            closeAddIngredientModal();
                            // Clear the form
                            // Reset subcategory select
                            const subcatSelect = document.getElementById('new-ingredient-subcategory');
                            subcatSelect.innerHTML = '<option value="">None</option>';
                        })
                        .catch(error => {
                            console.error('Error adding ingredient:', error);
                            alert('Error adding ingredient. Check the console for details.');
                        });
                });

                // Dynamically populate subcategories based on selected category
                const categorySelect = document.getElementById('new-ingredient-category');
                const subcategorySelect = document.getElementById('new-ingredient-subcategory');
                categorySelect.addEventListener('change', function() {
                    const category = this.value;
                    subcategorySelect.innerHTML = '<option value="">None</option>'; // Reset to default
                    if (category) {
                        fetch(`/subcategories/${encodeURIComponent(category)}`)
                            .then(response => {
                                if (!response.ok) {
                                }
                                return response.json();
                            })
                            .then(subcategories => {
                                subcategories.forEach(sub => {
                                    const option = document.createElement('option');
                                    option.value = sub;
                                    option.textContent = sub;
                                    subcategorySelect.appendChild(option);
                                });
                            })
                            .catch(error => {
                                console.error('Error fetching subcategories:', error);
                            });
                    }
                });
            }
        });

        let activeCard = null;

        function collapseCard(card) {
            if (!card) {
                return;
            }
            const details = card.querySelector('.recipe-card-details');
            if (details) {
                details.classList.add('hidden');
            }
            const toggle = card.querySelector('.recipe-card-toggle');
            if (toggle) {
                toggle.setAttribute('aria-expanded', 'false');
            }
            card.classList.remove('ring-2', 'ring-logo');
            if (activeCard === card) {
                activeCard = null;
            }
            if (currentDrink === card.dataset.drink) {
                currentDrink = null;
            }
        }

        function renderRecipeDetails(card, data) {
            const details = card.querySelector('.recipe-card-details');
            if (!details) {
                return;
            }

            const summaryLine = card.querySelector('.recipe-summary');
            if (summaryLine) {
                const spiritIngredients = summarizeSpiritIngredients(data.ingredients || []);
                const ingredientSummary = spiritIngredients.join(' | ');
                const summaryText = ingredientSummary || 'No spirits listed';
                summaryLine.textContent = summaryText;
                summaryLine.title = summaryText;
                card.dataset.spiritSummary = summaryText;
            }

            const ingredientsMarkup = (data.ingredients || []).map(ing => {
                const parts = [ing.quantity, ing.unit, ing.ingredient].filter(Boolean).join(' ').trim();
                return `<li class="flex items-start text-sm text-text-normal">${parts || 'Ingredient'}</li>`;
            }).join('');

            const ingredientsHtml = ingredientsMarkup || '<li class="text-sm text-text-muted">No ingredients listed.</li>';

            const drinkName = data.name || card.dataset.drink;
            const glass = data.glass || 'None';
            const garnish = data.garnish || 'None';
            const method = data.method || 'None';
            const ice = data.ice || data.Ice || 'None';
            const notes = data.notes || 'None';

            details.innerHTML = `
                <div class="space-y-4">
                    <div>
                        <p class="text-xs uppercase tracking-wide text-text-muted mb-1">Ingredients</p>
                        <ul class="space-y-1">${ingredientsHtml}</ul>
                    </div>
                    <div class="grid grid-cols-2 gap-2 text-xs uppercase tracking-wide text-text-muted">
                        <span>Glass</span><span class="text-sm text-text-normal">${glass}</span>
                        <span>Garnish</span><span class="text-sm text-text-normal">${garnish}</span>
                        <span>Method</span><span class="text-sm text-text-normal">${method}</span>
                        <span>Ice</span><span class="text-sm text-text-normal">${ice}</span>
                    </div>
                    <div>
                        <p class="text-xs uppercase tracking-wide text-text-muted mb-1">Notes</p>
                        <p class="text-sm text-text-normal whitespace-pre-wrap">${notes}</p>
                    </div>
                    <div class="flex flex-wrap gap-3 pt-2">
                        <button type="button" class="recipe-card-edit rounded-full bg-logo px-4 py-2 text-light-text-normal text-sm hover:ring-2 hover:ring-logo transition">Edit</button>
                        <button type="button" class="recipe-card-delete rounded-full border border-border px-4 py-2 text-sm text-text-normal hover:bg-background-light transition">Delete</button>
                    </div>
                </div>
            `;

            const editButton = details.querySelector('.recipe-card-edit');
            const deleteButton = details.querySelector('.recipe-card-delete');

            if (editButton) {
                editButton.addEventListener('click', () => {
                    openEditModal(drinkName);
                });
            }
            if (deleteButton) {
                deleteButton.addEventListener('click', () => {
                    currentDrink = drinkName;
                    const modal = document.getElementById('delete-modal');
                    const message = document.getElementById('delete-modal-message');
                    message.textContent = `Are you sure you want to delete ${drinkName}?`;
                    if (modal) {
                        modal.classList.remove('hidden');
                        modal.style.display = 'flex';
                    }
                });
            }
        }

        function loadRecipeDetails(card) {
            const drink = card.dataset.drink;
            const details = card.querySelector('.recipe-card-details');
            if (!details) {
                return;
            }

            details.innerHTML = '<p class="text-sm text-text-muted">Loading details...</p>';

            fetch(`/recipe/${encodeURIComponent(drink)}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    const baseSpiritValue = data.base_spirit && data.base_spirit.trim()
                        ? data.base_spirit.trim()
                        : '';
                    card.dataset.baseSpirit = baseSpiritValue;
                    const resolvedCategory = resolveBaseCategory(baseSpiritValue);
                    card.dataset.baseCategory = resolvedCategory;
                    renderRecipeDetails(card, data);
                    card.dataset.loaded = 'true';
                })
                .catch(error => {
                    console.error('Error fetching recipe:', error);
                    details.innerHTML = '<p class="text-sm text-text-muted">Unable to load recipe details.</p>';
                });
        }

        function toggleRecipeCard(card) {
            if (!card) {
                return;
            }
            if (card === activeCard) {
                collapseCard(card);
                return;
            }
            if (activeCard) {
                collapseCard(activeCard);
            }
            activeCard = card;
            currentDrink = card.dataset.drink;
            card.classList.add('ring-2', 'ring-logo');
            const toggle = card.querySelector('.recipe-card-toggle');
            if (toggle) {
                toggle.setAttribute('aria-expanded', 'true');
            }
            const details = card.querySelector('.recipe-card-details');
            if (details) {
                details.classList.remove('hidden');
                if (card.dataset.loaded !== 'true') {
                    loadRecipeDetails(card);
                }
            }
        }

        function initializeRecipeCards() {
            const toggles = document.querySelectorAll('.recipe-card-toggle');
            toggles.forEach(toggle => {
                toggle.setAttribute('aria-expanded', 'false');
                toggle.addEventListener('click', () => {
                    const card = toggle.closest('.recipe-card');
                    toggleRecipeCard(card);
                });
            });
        }
        window.filterCards = function() {
            const nameInput = document.getElementById('filter-name');
            const spiritInput = document.getElementById('filter-spirit');
            const nameFilter = nameInput ? nameInput.value.trim().toLowerCase() : '';
            const spiritFilter = spiritInput ? spiritInput.value.trim().toLowerCase() : '';

            const cards = document.querySelectorAll('.recipe-card');
            let visibleCount = 0;

            cards.forEach(card => {
                const drinkName = (card.dataset.drink || '').toLowerCase();
                const baseSpirit = (card.dataset.baseSpirit || '').toLowerCase();
                const baseCategory = (card.dataset.baseCategory || '').trim().toLowerCase();
                const matchesName = !nameFilter || drinkName.includes(nameFilter);
                const matchesSpirit =
                    !spiritFilter ||
                    baseSpirit.includes(spiritFilter) ||
                    baseCategory.includes(spiritFilter);
                const shouldShow = matchesName && matchesSpirit;
                card.classList.toggle('hidden', !shouldShow);
                if (!shouldShow && activeCard === card) {
                    collapseCard(card);
                }
                if (shouldShow) {
                    visibleCount += 1;
                }
            });

            const groups = document.querySelectorAll('.recipe-group');
            groups.forEach((group) => {
                const visibleCardsInGroup = Array.from(group.querySelectorAll('.recipe-card'))
                    .filter((card) => !card.classList.contains('hidden'));
                group.classList.toggle('hidden', visibleCardsInGroup.length === 0);
            });

            const emptyState = document.getElementById('recipes-empty');
            if (emptyState) {
                emptyState.classList.toggle('hidden', visibleCount !== 0);
            }

            return visibleCount;
        };

        window.resetRecipeFilters = function() {
            const nameInput = document.getElementById('filter-name');
            const spiritInput = document.getElementById('filter-spirit');
            if (nameInput) {
                nameInput.value = '';
            }
            if (spiritInput) {
                spiritInput.value = '';
            }
            filterCards();
        };
        function openAddModal() {
            const modal = document.getElementById('add-modal');
            modal.classList.remove('hidden');
            modal.style.display = 'flex';
            ingredientCount = 1;
            const list = document.getElementById('add-ingredients-list');
            if (list) {
                list.innerHTML = makeIngredientRowMarkup(0);
            }
        }

        function closeAddModal() {
            const modal = document.getElementById('add-modal');
            const form = document.getElementById('add-recipe-form');
            form.reset();
            modal.style.display = 'none';
            modal.classList.add('hidden');
            ingredientCount = 1;
            const list = document.getElementById('add-ingredients-list');
            if (list) {
                list.innerHTML = makeIngredientRowMarkup(0);
            }
        }

        function addIngredient(modalType) {
            const list = document.getElementById(modalType + '-ingredients-list');
            const count = (modalType === 'add' ? ingredientCount++ : editIngredientCount++);
            if (!list) {
                return;
            }
            list.insertAdjacentHTML('beforeend', makeIngredientRowMarkup(count));
        }

        function removeIngredient(button) {
            button.parentElement.remove();
        }

        function filterIngredients(input, index) {
            if (!input) {
                return;
            }
            const field = input.closest('.ingredient-field');
            const dropdown = field ? field.querySelector('.ingredient-dropdown') : null;
            if (!dropdown) {
                console.error('Invalid dropdown element for input:', input);
                return;
            }

            const rawValue = input.value.trim();
            const value = rawValue.toLowerCase();
            dropdown.innerHTML = '';
            dropdown.classList.add('hidden');
            dropdown.classList.remove('ingredient-dropdown--above');
            dropdown.style.maxHeight = '';

            if (!value) {
                dropdown.classList.add('hidden');
                dropdown.style.maxHeight = '';
                return;
            }

            const options = Array.isArray(allIngredientOptions) ? allIngredientOptions : [];
            const matches = options.filter((opt) => opt.toLowerCase().includes(value));
            const fragment = document.createDocumentFragment();

            matches.forEach((opt) => {
                const option = document.createElement('button');
                option.type = 'button';
                option.className = 'ingredient-option';
                option.textContent = opt;
                option.setAttribute('role', 'option');
                option.addEventListener('click', () => {
                    input.value = opt;
                    dropdown.classList.add('hidden');
                    dropdown.innerHTML = '';
                    dropdown.classList.remove('ingredient-dropdown--above');
                    dropdown.style.maxHeight = '';
                });
                fragment.appendChild(option);
            });

            if (!matches.length) {
                const empty = document.createElement('div');
                empty.className = 'ingredient-option-empty';
                empty.textContent = 'No matches found';
                fragment.appendChild(empty);
            }

            const hasExactMatch = matches.some((opt) => opt.toLowerCase() === value);
            if (rawValue && !hasExactMatch) {
                const addButton = document.createElement('button');
                addButton.type = 'button';
                addButton.className = 'ingredient-option ingredient-option-add';
                addButton.textContent = `Add "${rawValue}"`;
                addButton.addEventListener('click', (event) => {
                    event.preventDefault();
                    openAddIngredientModal(rawValue, input, index);
                    dropdown.classList.add('hidden');
                    dropdown.innerHTML = '';
                    dropdown.classList.remove('ingredient-dropdown--above');
                    dropdown.style.maxHeight = '';
                });
                fragment.appendChild(addButton);
            }

            dropdown.appendChild(fragment);

            if (!dropdown.childElementCount) {
                dropdown.classList.add('hidden');
                dropdown.style.maxHeight = '';
                return;
            }

            dropdown.classList.remove('hidden');
            dropdown.scrollTop = 0;

            window.requestAnimationFrame(() => {
                const modalBody = dropdown.closest('.modal-body');
                if (!modalBody) {
                    dropdown.style.maxHeight = '';
                    return;
                }
                const bodyRect = modalBody.getBoundingClientRect();
                const fieldRect = field.getBoundingClientRect();
                const dropdownHeight = dropdown.scrollHeight;
                const gutter = 8;
                const spaceBelow = Math.max(0, bodyRect.bottom - fieldRect.bottom - gutter);
                const spaceAbove = Math.max(0, fieldRect.top - bodyRect.top - gutter);
                const shouldOpenUp = dropdownHeight > spaceBelow && spaceAbove > spaceBelow;
                dropdown.classList.toggle('ingredient-dropdown--above', shouldOpenUp);
                const availableSpace = shouldOpenUp ? spaceAbove : spaceBelow;
                if (availableSpace > 0) {
                    dropdown.style.maxHeight = `${Math.min(dropdownHeight, availableSpace)}px`;
                } else {
                    dropdown.style.maxHeight = '';
                }
            });

            const closeOnOutsideClick = (event) => {
                if (field && !field.contains(event.target)) {
                    dropdown.classList.add('hidden');
                    dropdown.innerHTML = '';
                    dropdown.classList.remove('ingredient-dropdown--above');
                    dropdown.style.maxHeight = '';
                    document.removeEventListener('click', closeOnOutsideClick);
                }
            };

            window.setTimeout(() => {
                document.addEventListener('click', closeOnOutsideClick);
            }, 0);
        }

        function openAddIngredientModal(value, input, index) {
            const modal = document.getElementById('add-ingredient-modal');
            const nameInput = document.getElementById('new-ingredient-name');
            const form = document.getElementById('add-ingredient-form');
            nameInput.value = value;
            form.currentIngredientInput = input;
            form.dataset.index = index;
            modal.classList.remove('hidden');
            modal.style.display = 'flex';
        }

        function openEditModal(drink) {
            fetch(`/recipe/${encodeURIComponent(drink)}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    const editModal = document.getElementById('edit-modal');
                    if (editModal) {
                        editModal.classList.remove('hidden');
                        editModal.style.display = 'flex';
                    }
                    document.getElementById('edit-original-drink').value = data.name || '';
                    document.getElementById('edit-drink').value = data.name || '';
                    const baseSpiritInput = document.getElementById('edit-base_spirit-input');
                    if (baseSpiritInput) {
                        baseSpiritInput.value = data.base_spirit || '';
                    }
                    document.getElementById('edit-base_spirit').value = data.base_spirit || '';
                    document.getElementById('edit-glass').value = data.glass || '';
                    document.getElementById('edit-garnish').value = data.garnish || '';
                    document.getElementById('edit-method').value = data.method || '';
                    const iceInput = document.getElementById('edit_ice');
                    if (iceInput) {
                        iceInput.value = data.ice || '';
                    }
                    document.getElementById('edit-notes').value = data.notes || '';

                    const ingredientsList = document.getElementById('edit-ingredients-list');
                    ingredientsList.innerHTML = '';
                    editIngredientCount = 0;

                    if (data.ingredients && Array.isArray(data.ingredients)) {
                        data.ingredients.forEach((ing, index) => {
                            ingredientsList.insertAdjacentHTML('beforeend', makeIngredientRowMarkup(index));
                            const row = ingredientsList.lastElementChild;
                            if (!row) {
                                return;
                            }
                            const ingredientInput = row.querySelector(`input[name="ingredient_${index}"]`);
                            const quantityInput = row.querySelector(`input[name="quantity_${index}"]`);
                            const unitSelect = row.querySelector(`select[name="unit_${index}"]`);
                            if (ingredientInput) {
                                ingredientInput.value = ing.ingredient || '';
                            }
                            if (quantityInput) {
                                quantityInput.value = ing.quantity || '';
                            }
                            if (unitSelect) {
                                unitSelect.value = ing.unit || 'oz';
                            }
                            editIngredientCount = index + 1;
                        });
                    } else {
                        console.error('Invalid ingredients data:', data.ingredients);
                    }
                })
                .catch(error => {
                    console.error('Error fetching recipe:', error);
                    alert('Error fetching recipe details. Check the console for details.');
                });
        }

        function closeEditModal() {
            const modal = document.getElementById('edit-modal');
            modal.style.display = 'none';
            modal.classList.add('hidden');
            const form = document.getElementById('edit-recipe-form');
            form.reset();
            document.getElementById('edit-ingredients-list').innerHTML = '';
            editIngredientCount = 0;
        }

        function saveEdit() {
            const form = document.getElementById('edit-recipe-form');
            const iceInput = form.querySelector('#edit_ice');
            const data = {
                original_drink: form.querySelector('#edit-original-drink').value,
                drink: form.querySelector('#edit-drink').value,
                glass: form.querySelector('#edit-glass').value,
                garnish: form.querySelector('#edit-garnish').value,
                method: form.querySelector('#edit-method').value,
                Ice: iceInput ? iceInput.value : '',
                notes: form.querySelector('#edit-notes').value,
                base_spirit: form.querySelector('#edit-base_spirit').value,
                ingredients: []
            };

            const ingredientRows = form.querySelectorAll('#edit-ingredients-list .ingredient-row');
            ingredientRows.forEach(row => {
                const ingredient = row.querySelector(`input[name^="ingredient_"]`).value;
                const quantity = row.querySelector(`input[name^="quantity_"]`).value;
                const unit = row.querySelector(`select[name^="unit_"]`).value;
                if (ingredient && quantity && unit) {
                    data.ingredients.push({ ingredient, quantity, unit });
                }
            });

            const url = `/recipe/edit_recipe/${encodeURIComponent(data.original_drink)}`;

            fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            })
                .then(response => {
                    if (!response.ok) {
                        return response.text().then(text => {
                            throw new Error(`HTTP error! Status: ${response.status}, Response: ${text}`);
                        });
                    }
                    return response.json();
                })
                .then(result => {
                    if (result.success) {
                        showToast("Recipe updated successfully!");
                        closeEditModal();
                        sessionStorage.setItem('selectedDrink', data.drink);
                        setTimeout(() => location.reload(), 1000);
                    } else {
                        showToast(result.message || "Failed to update recipe.");
                        console.error('Update failed:', result.message);
                    }
                })
                .catch(error => {
                    console.error('Fetch error:', error);
                    showToast("Error saving recipe. See console.");
                });
        }

        function deleteRecipe(drink) {
            fetch(`/recipe/delete_recipe/${encodeURIComponent(drink)}`, {
                method: 'DELETE'
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    closeDeleteModal();
                    location.reload();
                })
                .catch(error => {
                    console.error('Error deleting recipe:', error);
                    alert('Error deleting recipe: ' + error.message);
                    closeDeleteModal();
                });
        }

        function closeDeleteModal() {
            const modal = document.getElementById('delete-modal');
            if (!modal) {
                return;
            }
            modal.style.display = 'none';
            modal.classList.add('hidden');
        }

        function filterBaseSpirit(modalType) {
            const input = document.getElementById(`${modalType}-base_spirit-input`);
            const select = document.getElementById(`${modalType}-base_spirit`);
            const field = input ? input.closest('.base-spirit-field') : null;
            const dropdown = field ? field.querySelector('.ingredient-dropdown') : null;

            if (!input || !select || !dropdown) {
                console.error(`Missing elements for ${modalType}-base_spirit:`, { input, select, dropdown });
                return;
            }

            const rawValue = input.value.trim();
            const value = rawValue.toLowerCase();
            dropdown.innerHTML = '';
            dropdown.classList.add('hidden');
            dropdown.classList.remove('ingredient-dropdown--above');
            dropdown.style.maxHeight = '';

            if (!value) {
                select.value = '';
                return;
            }

            const options = Array.from(select.options).slice(1);
            const matches = options.filter((option) => {
                const optionValue = option.value.toLowerCase();
                const optionText = option.text.toLowerCase();
                return optionValue.includes(value) || optionText.includes(value);
            });

            const fragment = document.createDocumentFragment();

            matches.forEach((option) => {
                const button = document.createElement('button');
                button.type = 'button';
                button.className = 'ingredient-option';
                button.textContent = option.text;
                button.setAttribute('role', 'option');
                button.addEventListener('click', () => {
                    input.value = option.value;
                    select.value = option.value;
                    dropdown.classList.add('hidden');
                    dropdown.innerHTML = '';
                    dropdown.classList.remove('ingredient-dropdown--above');
                    dropdown.style.maxHeight = '';
                });
                fragment.appendChild(button);
            });

            if (!matches.length) {
                const emptyState = document.createElement('div');
                emptyState.className = 'ingredient-option-empty';
                emptyState.textContent = 'No spirits found';
                fragment.appendChild(emptyState);
            }

            dropdown.appendChild(fragment);

            if (!dropdown.childElementCount) {
                dropdown.classList.add('hidden');
                dropdown.style.maxHeight = '';
                return;
            }

            dropdown.classList.remove('hidden');
            dropdown.scrollTop = 0;

            window.requestAnimationFrame(() => {
                const modalBody = dropdown.closest('.modal-body');
                if (!modalBody || !field) {
                    dropdown.style.maxHeight = '';
                    return;
                }
                const fieldRect = field.getBoundingClientRect();
                const bodyRect = modalBody.getBoundingClientRect();
                const dropdownHeight = dropdown.scrollHeight;
                const gutter = 8;
                const spaceBelow = Math.max(0, bodyRect.bottom - fieldRect.bottom - gutter);
                const spaceAbove = Math.max(0, fieldRect.top - bodyRect.top - gutter);
                const shouldOpenUp = dropdownHeight > spaceBelow && spaceAbove > spaceBelow;
                dropdown.classList.toggle('ingredient-dropdown--above', shouldOpenUp);
                const availableSpace = shouldOpenUp ? spaceAbove : spaceBelow;
                dropdown.style.maxHeight = availableSpace > 0
                    ? `${Math.min(dropdownHeight, availableSpace)}px`
                    : '';
            });

            const closeOnOutsideClick = (event) => {
                if (field && !field.contains(event.target)) {
                    dropdown.classList.add('hidden');
                    dropdown.innerHTML = '';
                    dropdown.classList.remove('ingredient-dropdown--above');
                    dropdown.style.maxHeight = '';
                    document.removeEventListener('click', closeOnOutsideClick);
                }
            };

            window.setTimeout(() => {
                document.addEventListener('click', closeOnOutsideClick);
            }, 0);
        }
    </script>

{% endblock %}































